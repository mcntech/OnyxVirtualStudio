#include "stdafx.h"
#include "SkypeUi.h"
#include "PluginSkypeIf.h"
#include "Dbg.h"
#include <string>
#include "SharedmemIf.h"
#include "OnyxControl.h"

#define SID_MAKEFOURCC(ch0, ch1, ch2, ch3) \
        ( (unsigned long)(unsigned char)(ch0)         | ( (unsigned long)(unsigned char)(ch1) << 8 ) | \
        ( (unsigned long)(unsigned char)(ch2) << 16 ) | ( (unsigned long)(unsigned char)(ch3) << 24 ) )

QSKSignalDispatcher *dispatcher = NULL;
QSKSkype *skype = NULL;


void QSKSignalDispatcher::SendToLogSignal(std::string msg)
{
	DbgOut(DBG_LVL_MSG, (msg.c_str()));
}


void QSKSignalDispatcher::OtherSessionClosed ()
{
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();
	pSkypeUi->on_OtherSessionClosed();
}

//------------------------------------------------------------------------------------------------
// Account methods

void QSKAccount::OnChange(int prop)
{
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();

    if (prop == Account::P_STATUS)
    {
        Account::STATUS accountStatus;
        this->GetPropStatus(accountStatus);
        std::string loginStatus = std::string((const char*)tostring(accountStatus));
        dispatcher->SendToLogSignal(loginStatus);
		std::string strReason;
		Account::LOGOUTREASON whyDidWeLogout = Account::LOGOUT_CALLED;          
        if (accountStatus == Account::LOGGED_IN)  {
            // Setting recently live delay to 0 seconds
            // This simplifies detection of incoming calls.
            skype->SetInt(SETUPKEY_RECENTLY_LIVE_TIMEOUT, 0);

            skype->isLoggedIn = true;
            dispatcher->EnableCallBtnSignal(true);
            pSkypeUi->UpdateContactList();
            dispatcher->SendToLogSignal("Note that the webcam is not yet available.");
            dispatcher->SendToLogSignal("Better wait a few seconds until video device list gets updated.");

            skype->GetConversationList(skype->inbox, Conversation::INBOX_CONVERSATIONS);
            fetch(skype->inbox);
        }  else if (accountStatus == Account::LOGGED_OUT) {
            skype->isLoggedIn = false;
            dispatcher->SendToLogSignal("Logout complete.");
            dispatcher->EnableCallBtnSignal(false);
            this->GetPropLogoutreason(whyDidWeLogout);
            strReason = std::string((const char*)tostring(whyDidWeLogout));
            dispatcher->SendToLogSignal(strReason);
        };
		pSkypeUi->on_UpdateStatus(accountStatus, whyDidWeLogout);
    };
};

//------------------------------------------------------------------------------------------------
// ContactGroup methods

void QSKContactGroup::OnChange(const ContactRef &contact)
{
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();
	ContactGroup::TYPE groupType;
	this->GetPropType(groupType);

	if (groupType == ContactGroup::SKYPE_BUDDIES) {
		SEString contactName;
		contact->GetPropDisplayname(contactName);

		if (!contactList.contains(contact)) {
			contactList.append(contact);
			contact.fetch();
			printf("%s was added.\n", (const char*)contactName);
		} else {
			contactList.remove_val(contact);
			printf("%s was removed.\n", (const char*)contactName);
		};
  };

	pSkypeUi->UpdateContactList();

};


//---------------------------------------------------------------------------------------
// QSKVideo class methods

QSKVideo::QSKVideo(unsigned int oid, SERootObject* root) : Video(oid, root)
{
    localPreview    = false;
    incomingStream  = false;
};

/* This notifiaction is common for both local preview and remote video */
void QSKVideo::OnChange(int prop)
{
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();

    if ( prop == Video::P_STATUS ) {
        Video::STATUS vidStatus;
        this->GetPropStatus(vidStatus);

        if ( this->localPreview )  {
            std::string dbg = "LOCAL ";
            dbg.append((const char*)tostring(vidStatus));
			if ( vidStatus == Video::RUNNING ) {
				pSkypeUi->on_OpenLocalVideo();
			} else if (vidStatus == Video::STOPPING) {
				pSkypeUi->on_CloseLocalVideo();
			}
			dispatcher->SendToLogSignal(dbg);
            return;
        };

        std::string dbg;
        if ( incomingStream ) dbg = "INCOMING "; else dbg = "OUTGOING ";
        dbg.append((const char*)tostring(vidStatus));
        dispatcher->SendToLogSignal(dbg);

        if ( vidStatus == Video::AVAILABLE ) 
			this->Start();

        if ( vidStatus == Video::RUNNING ) {
            if ( incomingStream ) {
                Conversation::Ref convX;
                this->GetPropConvoId(convX);
                dispatcher->SendToLogSignal("Incoming video stream is now running.");
				pSkypeUi->on_OpenIncomingVideo(this->participant);
			} else {

			}
        };

        if ( vidStatus == Video::STOPPING  ) {
			if( incomingStream ){
				pSkypeUi->on_CloseIncomingVideo(this->participant);
	
			} else {

			}
        };
    };
};


//---------------------------------------------------------------------------------------
// Participant class methods

QSKParticipant::QSKParticipant(unsigned int oid, SERootObject* root) : Participant(oid, root)
{
    // populating the isMyself variable
    SEString accountName;
    SEString partName;
    skype->account->GetPropSkypename(accountName);
    this->GetPropIdentity(partName);
    isMyself = ( accountName.equals(partName) );

    GetVideoIfAvailable();
};

void QSKParticipant::OnChange(int prop)

{
	bool isRinging = false; // TODO move to skype
    if (prop == Participant::P_VIDEO_STATUS ) 
		GetVideoIfAvailable();

	SEString identity;
	GetPropIdentity(identity);
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();
	if (prop == Participant::P_VOICE_STATUS) {
		Participant::VOICE_STATUS voiceStatus;
		GetPropVoiceStatus(voiceStatus);
		if (voiceStatus == Participant::RINGING) { 
			isRinging = true; 
		};

		switch (voiceStatus)
		{
		  case Participant::RINGING : 
			  DbgOut(DBG_LVL_MSG, ("Calling %s..\n", (const char*)identity));
			  break;
	      
		  case Participant::SPEAKING : 
			  DbgOut(DBG_LVL_MSG,("%s has joined live state\n", (const char*)identity));
			  break;

		  case Participant::LISTENING : 
			  DbgOut(DBG_LVL_MSG,("%s has joined live state\n", (const char*)identity));
			  break;

		  case Participant::VOICE_STOPPED : 
			  DbgOut(DBG_LVL_MSG,("%s has dropped from live state\n", (const char*)identity));
			  break;
	      
		  default:DbgOut(DBG_LVL_MSG,("Other Status(id=%d): %s\n", voiceStatus, (const char*)identity));
			// Ignoring other states for now..
			break;
		};
		if(!isMyself) {
			pSkypeUi->on_OutgoingCall(voiceStatus, (const char*)identity);
		}
	};

};

void QSKParticipant::GetVideoIfAvailable()
{
    Participant::VIDEO_STATUS partVidStatus;
    this->GetPropVideoStatus(partVidStatus);

    if (partVidStatus == Participant::VIDEO_AVAILABLE)  {
        bool fRes = this->GetVideo(video);
		if(fRes) {
			video.fetch();
			if(this->isMyself) {
				video->localPreview = true;
			} else {
				video->incomingStream = true;;
			}
			video->participant = this->ref();

			Video::STATUS vidStatus;
			video->GetPropStatus(vidStatus);
			if ( vidStatus == Video::AVAILABLE ) 
				video->Start();
		}
    };
};

void QSKParticipant::OnIncomingDTMF(const DTMF& dtmf)
{
	char szTmp[32];
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();

    String identity = GetStrProp(Participant::P_IDENTITY);
	std::string msg = "OnIncomingDTMF: ";
	msg.append( (const char*)identity );
	msg.append (":" );
	itoa((int)dtmf,szTmp,10);
	msg.append (szTmp);
	dispatcher->SendToLogSignal(msg);
	pSkypeUi->on_DtmfKeyReceived(this->ref(), (int)dtmf);

}

//---------------------------------------------------------------------------------------
// Conversation class methods

void QSKConversation::OnChange(int prop)
{
	if (prop == Conversation::P_LOCAL_LIVESTATUS)  {
		Conversation::LOCAL_LIVESTATUS liveStatus;
		GetPropLocalLivestatus(liveStatus);
		if ((liveStatus == Conversation::RECENTLY_LIVE) || (liveStatus == Conversation::NONE)) {
			DbgOut(DBG_LVL_MSG,("Call finished.\n"));
			this->callFinished = true;
		} else {
			DbgOut(DBG_LVL_MSG,("QSKConversation::OnChange  prop=%d liveStatus=%d.\n", prop,liveStatus));
		}
	} else {
		DbgOut(DBG_LVL_MSG,("QSKConversation::OnChange %d.\n",prop));
	}
};

void QSKConversation::OnParticipantListChange()
{
    // Keeping participant list updated

    this->GetParticipants(allParticipants);
    fetch(allParticipants);
};

const char *mszSelectedCamera = "Onyx Virtual Camera";
int QSKSkype::SelectLocalCaptureDevice()
{

	Sid::List_String lVideoDeviceNames, lVideoDevicePaths;	
	uint numVideoDevices;

	this->GetAvailableVideoDevices(lVideoDeviceNames, lVideoDevicePaths, numVideoDevices);
	for(uint i = 0; i < numVideoDevices; i++) {
		if(strcmp((const char *)lVideoDeviceNames[i],mszSelectedCamera) == 0) {
			this->SetStr(SETUPKEY_VIDEO_DEVICE, (const char*)lVideoDeviceNames[i]);
			this->SetStr(SETUPKEY_VIDEO_DEVICE_PATH, (const char*)lVideoDevicePaths[i]);
			return i;
		}
	}

	return -1;
}

//------------------------------------------------------------------------------------------------
// Skype methods

void QSKSkype::OnAvailableVideoDeviceListChange()
{
    SEStringList deviceNames;
    SEStringList deviceIds;
    uint deviceCount;
    this->GetAvailableVideoDevices(deviceNames, deviceIds, deviceCount);
    if (deviceCount > 0)    {
		int devNum = SelectLocalCaptureDevice();
		if(devNum >= 0) {
			dispatcher->SendToLogSignal("Video device list retrieved.");
			this->videoDeviceName = deviceNames[devNum];
			this->videoDeviceId = deviceIds[devNum];
			std::string msg = "Picking ";
			msg.append( (const char*)videoDeviceName );
			dispatcher->SendToLogSignal(msg);
			this->isVideoCapable = true;
		}
    } else {
        this->isVideoCapable = false;
        dispatcher->SendToLogSignal("ERROR: no video devices found.");
    };
};


void QSKSkype::OnConversationListChange(
        const ConversationRef &conversation,
        const Conversation::LIST_TYPE &type,
        const bool &added)
{
	CSkypeUi *pSkypeUi = CSkypeUi::Instance();
    // Keeping inbox updated..
	Conversation::LOCAL_LIVESTATUS liveStatus;
	conversation->GetPropLocalLivestatus(liveStatus);
    if ( (type == Conversation::INBOX_CONVERSATIONS) && (added) )  {
        this->GetConversationList(inbox, Conversation::INBOX_CONVERSATIONS);
        fetch(inbox);
    };

    if (type == Conversation::LIVE_CONVERSATIONS) {
        // Live call coming up
        if (added) {
            SEString whosCalling;
			SEString partId;
            conversation->GetPropDisplayname(whosCalling);
			conversation->GetPropIdentity(partId);

            if (skype->isLiveSessionUp) {
				pSkypeUi->on_IncomingCall(liveStatus, (const char *)whosCalling);
            } else {
                skype->isLiveSessionUp = true;
                skype->liveSession = conversation;
				if (liveStatus == Conversation::RINGING_FOR_ME) {
					//liveSession = conversation->ref();
					//liveSession.fetch();
					//liveSession->PickUpCall();
					DbgOut(DBG_LVL_MSG, ("Ringing for me."));
					if(skype->mfAutoAnswer){
						// TODO Check allowed participant list
						std::string uiMsg = (const char *)whosCalling;
						if(pSkypeUi->IsInAutoReplyList(partId)){
							conversation->JoinLiveSession();
							uiMsg += " : Auto reply : ";
							uiMsg += "Accept";
						} else {
							conversation->LeaveLiveSession();
							uiMsg += " : Auto reply : ";
							uiMsg += "Reject";
						}
						pSkypeUi->on_IncomingCall(liveStatus, uiMsg.c_str());
					} else {
						skype->mfAcceptCall = false;
						skype->mfUserActed = false;
						pSkypeUi->on_IncomingCall(liveStatus, (const char *)whosCalling);
						// Wait for user acceptance
						long lTimeOut =  5000;
						while (!skype->mfUserActed && lTimeOut > 0){
							Sleep(100);
							lTimeOut -= 100;
						}
						if(skype->mfAcceptCall) {
							conversation->JoinLiveSession();
						} else {
							conversation->LeaveLiveSession();
						}
					}

				} else {
					DbgOut(DBG_LVL_MSG, ("Not ringing for me."));
	                conversation->JoinLiveSession();
					pSkypeUi->on_IncomingCall(liveStatus, (const char *)whosCalling);
				}
            };
        }  else {
			if(skype->isLiveSessionUp && (skype->liveSession->getOID() == conversation->getOID())) {
				skype->isLiveSessionUp = false;
				skype->liveSession = NULL;
				DbgOut(DBG_LVL_MSG, ("Session Removed."));
				pSkypeUi->on_LiveSessionClosed();
			} else {
				// TODO:
				DbgOut(DBG_LVL_MSG, ("Session Removed from remote user ?"));
			}
			
        };
    };
};


void QSKSkype::PlaceCall(const char *szCallee)
{
	std::string target = szCallee;
    if (skype->isLiveSessionUp)  {
        dispatcher->SendToLogSignal("Cant do - we are already in a call.");
    }  else  {
		if ( target.empty() ) {
            dispatcher->SendToLogSignal("ERROR: no call target selected.");
        } else {
			SEString Target = (const char*)target.c_str();

            QSKConversation::Ref call;
            SEStringList callTargets;

            callTargets.append(Target);
            skype->GetConversationByParticipants(callTargets, call, true, true);
			call->dbgId = "Place Call";
            call->RingOthers();
            dispatcher->SendToLogSignal("Calling..");
        };
    };
};

int QSKSkype::Login(SEString accountName, SEString password)
{
	int res = 0;
    if (skype->GetAccount(accountName, skype->account))  {
        dispatcher->SendToLogSignal("Logging in..");
		if(!skype->account->LoginWithPassword(password, false, false)) {
			dispatcher->SendToLogSignal("ERROR: LoginWithPassword failed");
			res = -1;
		}
	} else {
		dispatcher->SendToLogSignal("ERROR: Account does not exist!");
		res = -1;
	}
	return res;
};
int QSKSkype::Logout()
{
	int res = 0;
    if (skype->account)  {
        dispatcher->SendToLogSignal("Logging in..");
		if(!skype->account->Logout()) {
			dispatcher->SendToLogSignal("ERROR: Logout failed");
			res = -1;
		}
	} else {
		dispatcher->SendToLogSignal("ERROR: Account does not exist!");
		res = -1;
	}
	return res;
};

//=============================================================================

void CVideoRx::renderStart()
{
	unsigned int list[2];
	list[0] = SID_MAKEFOURCC('B','I','3','2');
	ipc.setPreferences( 1, list );
	mCurrentwidth = 0;
	mActive = true;
}
void CVideoRx::renderStop()
{
	mActive = false;
	Sleep(100);
}

int CVideoRx::getFrame(CVideoFrame *pFrm)
{
	if(skype->isLiveSessionUp && mActive) {
		try
		{
			VideoTransportBase::bufferstruct *buffer = ipc.getNewFrame();
			if(buffer) {
				//buffer = ipc.getFrame();
				if(buffer) {
					if(mCurrentwidth != buffer->width){
						mCurrentwidth = buffer->width;
					}
					int nMaxSize = buffer->size;
					memcpy(pFrm->getBuffer(), (const uchar *)ipc.bufferData(buffer), nMaxSize);
					//pFrm->mBuffer =  (unsigned char *)ipc.bufferData(buffer);
					pFrm->mWidth = buffer->width;
					pFrm->mStride = pFrm->mWidth;
					pFrm->mHeight = buffer->height;
					pFrm->mSize = buffer->size;
					pFrm->mOrientation = buffer->orientation; 
					return 0;
				} 
			}
		}
		catch(...)
		{
			// Ignore the frame
			int m = 0;
		}
	}
	return -1;
}

int CVideoRx::CopyFrameToSharedMem(char *pSharedBuf)
{
	if(pSharedBuf == NULL)
		return -1;

	MCN_VID_FRAME_T *pFrame = (MCN_VID_FRAME_T *)pSharedBuf;
	char *pFrameBuff = (char *)(pSharedBuf + sizeof(MCN_VID_FRAME_T));

	VideoTransportBase::bufferstruct *buffer = ipc.getNewFrame();
	if(buffer) {
		int nMaxSize = buffer->size;
		memcpy(pFrameBuff, (const uchar *)ipc.bufferData(buffer), nMaxSize);
		//pFrm->mBuffer =  (unsigned char *)ipc.bufferData(buffer);

		pFrame->width = buffer->width;
		pFrame->stride = buffer->width;
		pFrame->height = buffer->height;
		pFrame->orientation = buffer->orientation;
		//buffer->size;
	}
	mFrameCount++;

	return 0;
}

CSkypeUi::CSkypeUi() 
{
	memset(&mProcessInformation, 0x00, sizeof(PROCESS_INFORMATION));
	memset(&mStartupInfo, 0, sizeof(STARTUPINFOA));
	mStartupInfo.cb = sizeof(STARTUPINFOA);

	mVidRx = NULL;
	mpCallback = NULL;

	mRunMemStream = false;
	mMapFile =  INVALID_HANDLE_VALUE;
	mSharedBuf = NULL;
	mThread =  INVALID_HANDLE_VALUE;

	dispatcher = new QSKSignalDispatcher;
	skype = new QSKSkype;

}


CSkypeUi *CSkypeUi::Instance()
{
  if (!mInstance)
      mInstance = new CSkypeUi();
  return mInstance;
}

__declspec(dllexport) CSkypeIf* WINAPI CreateSkypeIfInstance()
{
  return CSkypeUi::Instance();
}

void CSkypeUi::on_OpenIncomingVideo(Participant::Ref part) 
{
	DbgOut(DBG_LVL_MSG, ("%s:Enter",__FUNCTION__));
	if(!mVidRx)
		mVidRx = new CVideoRx;

	SEString partId;
	part->GetPropLiveIdentity(partId);

	if(mpCallback) {
		mpCallback->VideoStatus(SKYPE_VIDEO_INCOMING_VIDEO_OPEN, (void *)((const char*)partId));
	}


	mVidRx->setParticipantName((const char*)partId);

	QSKParticipant::Ref p    = part;
	p->video->SetRemoteRendererId(mVidRx->getKey());

	mVidRx->renderStart();
	StartMemStream();

	DbgOut(DBG_LVL_MSG, ("%s:Leave",__FUNCTION__));
}

void CSkypeUi::on_OpenLocalVideo() 
{
	DbgOut(DBG_LVL_MSG, ("%s:Enter",__FUNCTION__));
	if(mpCallback) {
		mpCallback->VideoStatus(SKYPE_VIDEO_OUTGOING_VIDEO_OPEN, NULL);
	}
}

void CSkypeUi::on_CloseLocalVideo() 
{
	DbgOut(DBG_LVL_MSG, ("%s:Enter",__FUNCTION__));
	if(mpCallback) {
		mpCallback->VideoStatus(SKYPE_VIDEO_OUTGOING_VIDEO_CLOSE, NULL);
	}
}

void CSkypeUi::on_IncomingCall(int nStatusId, const char *party)
{
	if(mpCallback) {
		if(nStatusId == Conversation::RINGING_FOR_ME) {
			mpCallback->ConversationStatus(SKYPE_CONVERSATION_INCOMING_CALL_RINGING, (void *)party);
		}
	}
}

void CSkypeUi::on_OutgoingCall(int nStatusId, const char *party)
{
	int UiStatusId = SKYPE_PARTICIPANT_STATUS_UNKNOWN;
	if(mpCallback) {
		switch(nStatusId){
		  case Participant::RINGING : 
			  UiStatusId = SKYPE_PARTICIPANT_STATUS_RINGING;
			  break;
	      
		  case Participant::SPEAKING : 
			  UiStatusId = SKYPE_PARTICIPANT_STATUS_SPEAKING;
			  break;

		  case Participant::LISTENING : 
			  UiStatusId = SKYPE_PARTICIPANT_STATUS_LISTENING;
			  break;

		  case Participant::VOICE_STOPPED : 
			  UiStatusId = SKYPE_PARTICIPANT_STATUS_VOICE_STOPPED;
			  break;
		  default:
			  UiStatusId = SKYPE_PARTICIPANT_STATUS_UNKNOWN;
			  break;
		}
		mpCallback->ParticipantStatus(UiStatusId, (void *)party);
	}
}

void CSkypeUi::on_CloseIncomingVideo(Participant::Ref part)
{
	DbgOut(DBG_LVL_MSG, ("%s:Enter",__FUNCTION__));
	QSKParticipant::Ref p    = part;

	if(mpCallback) {
		mpCallback->VideoStatus(SKYPE_VIDEO_INCOMING_VIDEO_CLOSE, NULL);
	}

	p->video->SetRemoteRendererId(0);
#if 1
	StopMemStream();
#endif
	if(mVidRx) {
		mVidRx->renderStop();
		delete mVidRx;
		mVidRx = NULL;
	}
	DbgOut(DBG_LVL_MSG, ("%s:Leave",__FUNCTION__));
};

extern void SendOnyxDtmfKey( int dtmfKey );
void CSkypeUi::on_DtmfKeyReceived(Participant::Ref part, int dtmfKey)
{
	SendOnyxDtmfKey(dtmfKey);
}
CSkypeUi* CSkypeUi::mInstance = NULL;
//const char* keyFileName = "C:/Projects/skypekit-sdk_sdk-4.2.1.97_1379776/dev_keypair/Ovs_1.0.pem";
#ifdef CONVERT_KEY
void DumpKey(unsigned char *pKey)
{
	int i = 0;
	FILE* f = fopen("C:/Projects/OnyxVirtualStudio/OnyxVirtualStudio/bin/Debug/Skype.Hex", "w");
	fprintf(f,"{\n");
	while(pKey[i] != 0x00) {
		fprintf(f,"0x%02x,",pKey[i]);
		if(pKey[i] == '\n'){
			fprintf(f,"\n",pKey[i]);
		}
		i++;
	}
	fprintf(f,"0x00\n}");
	fclose(f);
}
#endif
unsigned char keyPair[] = 
{
0x2d,0x2d,0x2d,0x2d,0x2d,0x42,0x45,0x47,0x49,0x4e,0x20,0x52,0x53,0x41,0x20,0x50,0x52,0x49,0x56,0x41,0x54,0x45,0x20,0x4b,0x45,0x59,0x2d,0x2d,0x2d,0x2d,0x2d,0x0a,
0x4d,0x49,0x49,0x45,0x6f,0x67,0x49,0x42,0x41,0x41,0x4b,0x43,0x41,0x51,0x45,0x41,0x77,0x45,0x46,0x61,0x45,0x31,0x30,0x4f,0x54,0x4e,0x38,0x37,0x6b,0x37,0x38,0x33,0x55,0x61,0x76,0x51,0x57,0x79,0x77,0x50,0x37,0x30,0x43,0x67,0x34,0x48,0x52,0x73,0x48,0x4b,0x73,0x2f,0x4f,0x67,0x33,0x4f,0x41,0x75,0x6a,0x47,0x6f,0x37,0x33,0x79,0x0a,
0x51,0x68,0x64,0x6f,0x46,0x53,0x4d,0x32,0x65,0x42,0x71,0x31,0x34,0x46,0x66,0x75,0x73,0x6f,0x6c,0x72,0x6c,0x55,0x4f,0x37,0x57,0x6e,0x67,0x62,0x38,0x38,0x33,0x55,0x45,0x6c,0x67,0x6e,0x67,0x56,0x58,0x30,0x71,0x73,0x61,0x48,0x53,0x4a,0x6f,0x30,0x65,0x30,0x41,0x69,0x70,0x43,0x69,0x38,0x68,0x69,0x37,0x58,0x56,0x6d,0x39,0x70,0x0a,
0x66,0x2b,0x57,0x75,0x49,0x59,0x67,0x77,0x4c,0x4d,0x42,0x4b,0x35,0x4a,0x74,0x6c,0x44,0x41,0x4b,0x63,0x69,0x75,0x46,0x76,0x47,0x43,0x37,0x50,0x32,0x37,0x50,0x32,0x73,0x4d,0x4f,0x45,0x6f,0x63,0x38,0x50,0x42,0x6e,0x48,0x39,0x50,0x50,0x6b,0x41,0x53,0x7a,0x4c,0x6a,0x68,0x58,0x34,0x41,0x36,0x50,0x6e,0x33,0x33,0x6e,0x73,0x6a,0x0a,
0x5a,0x58,0x37,0x34,0x63,0x65,0x2f,0x31,0x6f,0x4f,0x6e,0x77,0x73,0x4e,0x58,0x75,0x5a,0x49,0x78,0x75,0x65,0x45,0x4c,0x68,0x73,0x4b,0x44,0x53,0x6a,0x31,0x4f,0x67,0x4b,0x71,0x79,0x69,0x67,0x53,0x39,0x66,0x35,0x5a,0x46,0x57,0x64,0x49,0x6e,0x44,0x33,0x39,0x6e,0x5a,0x36,0x57,0x4c,0x36,0x52,0x30,0x66,0x4d,0x6a,0x4d,0x4f,0x47,0x0a,
0x48,0x2f,0x33,0x39,0x37,0x31,0x63,0x49,0x54,0x37,0x41,0x6e,0x4e,0x6d,0x6b,0x2f,0x46,0x4f,0x62,0x70,0x6d,0x50,0x6e,0x57,0x37,0x42,0x77,0x44,0x52,0x38,0x46,0x48,0x6f,0x2f,0x4c,0x52,0x64,0x55,0x5a,0x30,0x58,0x47,0x68,0x67,0x2f,0x71,0x72,0x6c,0x50,0x6b,0x51,0x45,0x59,0x73,0x54,0x6e,0x77,0x64,0x76,0x72,0x79,0x33,0x32,0x6e,0x0a,
0x65,0x38,0x37,0x52,0x6a,0x6c,0x6f,0x38,0x42,0x73,0x55,0x50,0x5a,0x61,0x48,0x39,0x6b,0x2b,0x44,0x33,0x63,0x56,0x43,0x48,0x75,0x64,0x45,0x41,0x54,0x2f,0x79,0x62,0x34,0x64,0x74,0x59,0x45,0x51,0x49,0x44,0x41,0x51,0x41,0x42,0x41,0x6f,0x49,0x42,0x41,0x45,0x6f,0x44,0x58,0x72,0x67,0x42,0x70,0x52,0x57,0x33,0x41,0x75,0x71,0x59,0x0a,
0x50,0x4b,0x57,0x32,0x62,0x56,0x6f,0x4d,0x46,0x6e,0x35,0x57,0x39,0x52,0x67,0x7a,0x2b,0x63,0x4c,0x33,0x73,0x6a,0x6d,0x5a,0x51,0x75,0x77,0x66,0x7a,0x51,0x6b,0x51,0x67,0x51,0x6b,0x73,0x6c,0x61,0x63,0x39,0x6a,0x53,0x53,0x6a,0x73,0x38,0x30,0x51,0x54,0x52,0x5a,0x79,0x6a,0x50,0x5a,0x44,0x77,0x77,0x62,0x4c,0x49,0x6f,0x65,0x7a,0x0a,
0x66,0x36,0x63,0x6f,0x52,0x4e,0x30,0x6e,0x79,0x43,0x39,0x4f,0x69,0x70,0x70,0x4b,0x73,0x31,0x57,0x58,0x6c,0x54,0x35,0x35,0x61,0x45,0x71,0x49,0x45,0x65,0x4a,0x32,0x74,0x62,0x6a,0x46,0x4a,0x55,0x70,0x48,0x63,0x62,0x52,0x6f,0x75,0x75,0x78,0x54,0x58,0x6f,0x31,0x48,0x48,0x42,0x6a,0x6a,0x50,0x4b,0x2b,0x6b,0x70,0x65,0x54,0x41,0x0a,
0x33,0x59,0x47,0x6a,0x59,0x35,0x59,0x66,0x62,0x6e,0x74,0x65,0x75,0x73,0x30,0x55,0x56,0x79,0x61,0x63,0x43,0x72,0x64,0x44,0x6b,0x50,0x6f,0x66,0x52,0x67,0x71,0x39,0x67,0x4d,0x30,0x59,0x51,0x50,0x31,0x4f,0x39,0x50,0x38,0x46,0x6a,0x64,0x65,0x58,0x6a,0x4f,0x58,0x2f,0x6c,0x49,0x30,0x67,0x39,0x77,0x4b,0x71,0x46,0x6b,0x4e,0x32,0x0a,
0x4b,0x55,0x4f,0x36,0x41,0x51,0x6e,0x76,0x44,0x4a,0x6f,0x5a,0x61,0x5a,0x5a,0x59,0x6d,0x50,0x4d,0x74,0x74,0x57,0x59,0x35,0x44,0x47,0x55,0x37,0x69,0x66,0x38,0x5a,0x76,0x33,0x47,0x67,0x67,0x54,0x67,0x6a,0x47,0x54,0x42,0x68,0x73,0x73,0x4d,0x2f,0x32,0x49,0x2b,0x39,0x41,0x52,0x56,0x69,0x61,0x77,0x42,0x2f,0x5a,0x4c,0x6e,0x71,0x0a,
0x2b,0x44,0x31,0x52,0x4b,0x78,0x68,0x53,0x34,0x68,0x6d,0x39,0x36,0x64,0x47,0x4b,0x6f,0x46,0x71,0x59,0x42,0x53,0x44,0x47,0x6a,0x36,0x37,0x4f,0x52,0x34,0x66,0x38,0x2f,0x76,0x76,0x55,0x32,0x57,0x77,0x6d,0x68,0x2f,0x67,0x34,0x2b,0x63,0x75,0x70,0x74,0x2f,0x2f,0x6a,0x57,0x4a,0x57,0x58,0x57,0x34,0x66,0x35,0x36,0x52,0x32,0x77,0x0a,
0x2b,0x33,0x6c,0x56,0x67,0x69,0x45,0x43,0x67,0x59,0x45,0x41,0x38,0x4a,0x6a,0x42,0x39,0x4b,0x65,0x32,0x37,0x36,0x34,0x48,0x74,0x46,0x76,0x78,0x69,0x34,0x68,0x42,0x59,0x41,0x34,0x50,0x41,0x69,0x64,0x5a,0x31,0x49,0x4a,0x55,0x37,0x57,0x5a,0x7a,0x64,0x52,0x39,0x2b,0x74,0x49,0x2f,0x67,0x6d,0x74,0x47,0x6b,0x55,0x70,0x62,0x57,0x0a,
0x2b,0x6d,0x75,0x51,0x38,0x2b,0x5a,0x61,0x77,0x59,0x38,0x34,0x54,0x31,0x4f,0x38,0x52,0x38,0x49,0x76,0x56,0x44,0x5a,0x38,0x46,0x75,0x4f,0x30,0x67,0x65,0x43,0x36,0x70,0x37,0x5a,0x49,0x55,0x57,0x6d,0x62,0x66,0x63,0x35,0x45,0x78,0x39,0x4f,0x62,0x54,0x70,0x32,0x73,0x61,0x37,0x7a,0x76,0x55,0x36,0x59,0x2f,0x4d,0x42,0x4a,0x67,0x0a,
0x47,0x64,0x38,0x32,0x69,0x2f,0x69,0x52,0x58,0x48,0x31,0x48,0x34,0x65,0x67,0x34,0x38,0x6a,0x72,0x6b,0x41,0x4d,0x2b,0x47,0x77,0x6b,0x30,0x33,0x6c,0x61,0x34,0x43,0x31,0x2f,0x77,0x64,0x6b,0x44,0x31,0x36,0x51,0x79,0x73,0x61,0x4b,0x77,0x75,0x56,0x6c,0x79,0x33,0x46,0x79,0x51,0x55,0x43,0x67,0x59,0x45,0x41,0x7a,0x4a,0x42,0x4f,0x0a,
0x54,0x57,0x73,0x79,0x66,0x66,0x61,0x70,0x54,0x56,0x4c,0x6e,0x2f,0x55,0x6b,0x6f,0x50,0x75,0x54,0x6e,0x53,0x61,0x58,0x63,0x37,0x31,0x70,0x37,0x38,0x4c,0x59,0x4e,0x52,0x64,0x54,0x37,0x77,0x62,0x51,0x75,0x38,0x63,0x72,0x70,0x44,0x36,0x4e,0x35,0x6d,0x34,0x68,0x6a,0x68,0x48,0x5a,0x76,0x67,0x68,0x6a,0x43,0x50,0x59,0x6b,0x77,0x0a,
0x66,0x6f,0x39,0x38,0x58,0x58,0x51,0x4f,0x78,0x32,0x75,0x42,0x32,0x71,0x66,0x6e,0x66,0x75,0x45,0x37,0x53,0x6e,0x2b,0x53,0x6e,0x71,0x63,0x45,0x2b,0x7a,0x45,0x61,0x4d,0x33,0x64,0x67,0x4a,0x54,0x5a,0x37,0x31,0x59,0x53,0x2f,0x48,0x31,0x72,0x44,0x72,0x73,0x51,0x43,0x44,0x45,0x33,0x71,0x5a,0x76,0x31,0x6f,0x2b,0x51,0x71,0x6d,0x0a,
0x2f,0x37,0x69,0x37,0x43,0x45,0x48,0x37,0x62,0x6f,0x6b,0x61,0x57,0x66,0x4f,0x6e,0x65,0x48,0x52,0x52,0x53,0x67,0x4c,0x65,0x72,0x5a,0x6f,0x30,0x73,0x34,0x73,0x30,0x61,0x6c,0x51,0x2f,0x30,0x4a,0x30,0x43,0x67,0x59,0x41,0x39,0x7a,0x4e,0x38,0x31,0x4f,0x73,0x64,0x51,0x74,0x59,0x45,0x68,0x49,0x4f,0x54,0x67,0x6c,0x48,0x56,0x47,0x0a,
0x65,0x52,0x58,0x39,0x31,0x61,0x48,0x4c,0x5a,0x6c,0x62,0x75,0x53,0x2f,0x79,0x6f,0x50,0x78,0x6a,0x4b,0x78,0x4a,0x4a,0x4b,0x38,0x6b,0x4b,0x6c,0x50,0x44,0x32,0x6f,0x51,0x57,0x30,0x51,0x57,0x55,0x46,0x43,0x71,0x73,0x6b,0x71,0x42,0x7a,0x59,0x37,0x73,0x48,0x4e,0x37,0x7a,0x43,0x72,0x2f,0x72,0x69,0x6d,0x31,0x6d,0x73,0x59,0x58,0x0a,
0x51,0x6b,0x6b,0x39,0x4d,0x45,0x56,0x53,0x67,0x57,0x4e,0x46,0x65,0x4f,0x4e,0x52,0x78,0x45,0x70,0x2f,0x75,0x68,0x34,0x33,0x66,0x47,0x4b,0x4b,0x74,0x49,0x32,0x65,0x31,0x36,0x6b,0x70,0x4e,0x77,0x59,0x50,0x6e,0x64,0x61,0x53,0x2f,0x70,0x56,0x79,0x45,0x78,0x4a,0x78,0x36,0x74,0x79,0x51,0x6d,0x45,0x6b,0x49,0x31,0x35,0x4f,0x2f,0x0a,
0x61,0x76,0x45,0x6c,0x46,0x63,0x57,0x4c,0x37,0x30,0x78,0x66,0x64,0x6a,0x42,0x4d,0x6a,0x75,0x4e,0x5a,0x43,0x51,0x4b,0x42,0x67,0x47,0x47,0x41,0x59,0x71,0x49,0x4a,0x39,0x78,0x34,0x4d,0x35,0x48,0x4e,0x44,0x6b,0x65,0x6d,0x71,0x35,0x66,0x44,0x63,0x58,0x39,0x55,0x39,0x70,0x6b,0x6d,0x37,0x67,0x68,0x6d,0x67,0x58,0x45,0x45,0x74,0x0a,
0x6d,0x2f,0x57,0x65,0x73,0x55,0x56,0x30,0x4a,0x70,0x50,0x61,0x6f,0x6b,0x72,0x63,0x76,0x6a,0x70,0x54,0x7a,0x53,0x42,0x67,0x4e,0x71,0x7a,0x6e,0x35,0x2b,0x4a,0x61,0x39,0x37,0x62,0x2f,0x61,0x30,0x2f,0x6e,0x30,0x52,0x50,0x73,0x4e,0x61,0x33,0x48,0x49,0x75,0x43,0x47,0x58,0x39,0x63,0x59,0x32,0x6f,0x6e,0x7a,0x78,0x48,0x35,0x46,0x0a,
0x5a,0x75,0x45,0x31,0x7a,0x39,0x35,0x63,0x6b,0x46,0x41,0x63,0x6a,0x65,0x71,0x4e,0x36,0x44,0x2f,0x2f,0x48,0x7a,0x75,0x4a,0x69,0x33,0x41,0x77,0x67,0x4a,0x71,0x67,0x62,0x52,0x30,0x70,0x66,0x66,0x4d,0x59,0x6a,0x43,0x50,0x56,0x75,0x37,0x76,0x78,0x44,0x52,0x48,0x4f,0x76,0x6c,0x35,0x57,0x67,0x73,0x6f,0x56,0x44,0x70,0x32,0x6a,0x0a,
0x6e,0x47,0x73,0x4e,0x41,0x6f,0x47,0x41,0x4a,0x53,0x56,0x77,0x53,0x2b,0x77,0x64,0x73,0x6b,0x2b,0x30,0x32,0x63,0x52,0x61,0x6d,0x68,0x72,0x4a,0x52,0x73,0x41,0x32,0x6b,0x43,0x6f,0x33,0x55,0x63,0x70,0x6f,0x41,0x4b,0x6b,0x77,0x4d,0x54,0x32,0x38,0x59,0x38,0x63,0x4c,0x61,0x74,0x4d,0x73,0x6a,0x36,0x4c,0x39,0x44,0x65,0x58,0x42,0x0a,
0x6e,0x6b,0x54,0x4b,0x52,0x76,0x6e,0x48,0x36,0x37,0x69,0x6e,0x52,0x54,0x72,0x61,0x65,0x46,0x76,0x58,0x42,0x6a,0x42,0x6c,0x52,0x36,0x52,0x65,0x69,0x30,0x44,0x4f,0x41,0x57,0x34,0x6c,0x33,0x4d,0x69,0x38,0x50,0x4e,0x46,0x38,0x57,0x68,0x49,0x6a,0x38,0x44,0x74,0x4c,0x65,0x5a,0x4d,0x62,0x6b,0x41,0x73,0x45,0x73,0x53,0x4f,0x36,0x0a,
0x6b,0x4b,0x36,0x2f,0x52,0x49,0x32,0x41,0x61,0x6c,0x46,0x71,0x48,0x66,0x4b,0x34,0x67,0x6d,0x61,0x57,0x62,0x42,0x4c,0x62,0x67,0x33,0x79,0x69,0x33,0x69,0x48,0x38,0x2f,0x35,0x42,0x2b,0x79,0x71,0x68,0x6d,0x6a,0x42,0x62,0x6a,0x39,0x6c,0x59,0x4f,0x31,0x61,0x67,0x3d,0x0a,
0x2d,0x2d,0x2d,0x2d,0x2d,0x45,0x4e,0x44,0x20,0x52,0x53,0x41,0x20,0x50,0x52,0x49,0x56,0x41,0x54,0x45,0x20,0x4b,0x45,0x59,0x2d,0x2d,0x2d,0x2d,0x2d,0x0a,
0x2d,0x2d,0x2d,0x2d,0x2d,0x42,0x45,0x47,0x49,0x4e,0x20,0x43,0x45,0x52,0x54,0x49,0x46,0x49,0x43,0x41,0x54,0x45,0x2d,0x2d,0x2d,0x2d,0x2d,0x0a,
0x4d,0x49,0x49,0x44,0x50,0x7a,0x43,0x43,0x41,0x69,0x65,0x67,0x41,0x77,0x49,0x42,0x41,0x77,0x49,0x42,0x41,0x44,0x41,0x4e,0x42,0x67,0x6b,0x71,0x68,0x6b,0x69,0x47,0x39,0x77,0x30,0x42,0x41,0x51,0x55,0x46,0x41,0x44,0x42,0x6a,0x4d,0x53,0x4d,0x77,0x49,0x51,0x59,0x4a,0x4b,0x6f,0x5a,0x49,0x68,0x76,0x63,0x4e,0x41,0x51,0x6b,0x42,0x0a,
0x46,0x68,0x52,0x79,0x59,0x57,0x31,0x77,0x5a,0x57,0x35,0x72,0x5a,0x55,0x42,0x74,0x59,0x32,0x35,0x30,0x5a,0x57,0x4e,0x6f,0x4c,0x6d,0x4e,0x76,0x62,0x54,0x45,0x64,0x4d,0x42,0x73,0x47,0x41,0x31,0x55,0x45,0x41,0x77,0x77,0x55,0x54,0x55,0x4e,0x4f,0x49,0x46,0x52,0x6c,0x59,0x32,0x68,0x75,0x62,0x32,0x78,0x76,0x5a,0x32,0x6c,0x6c,0x0a,
0x63,0x79,0x42,0x4a,0x62,0x6d,0x4d,0x78,0x48,0x54,0x41,0x62,0x42,0x67,0x4e,0x56,0x42,0x41,0x73,0x4d,0x46,0x45,0x39,0x75,0x65,0x58,0x68,0x55,0x64,0x6c,0x4e,0x30,0x64,0x57,0x52,0x70,0x62,0x79,0x74,0x32,0x5a,0x58,0x4a,0x7a,0x61,0x57,0x39,0x75,0x4d,0x42,0x34,0x58,0x44,0x54,0x45,0x79,0x4d,0x44,0x6b,0x78,0x4d,0x44,0x41,0x79,0x0a,
0x4d,0x6a,0x51,0x30,0x4e,0x31,0x6f,0x58,0x44,0x54,0x4d,0x33,0x4d,0x44,0x6b,0x78,0x4d,0x44,0x41,0x79,0x4d,0x6a,0x51,0x30,0x4e,0x31,0x6f,0x77,0x59,0x7a,0x45,0x6a,0x4d,0x43,0x45,0x47,0x43,0x53,0x71,0x47,0x53,0x49,0x62,0x33,0x44,0x51,0x45,0x4a,0x41,0x52,0x59,0x55,0x63,0x6d,0x46,0x74,0x63,0x47,0x56,0x75,0x61,0x32,0x56,0x41,0x0a,
0x62,0x57,0x4e,0x75,0x64,0x47,0x56,0x6a,0x61,0x43,0x35,0x6a,0x62,0x32,0x30,0x78,0x48,0x54,0x41,0x62,0x42,0x67,0x4e,0x56,0x42,0x41,0x4d,0x4d,0x46,0x45,0x31,0x44,0x54,0x69,0x42,0x55,0x5a,0x57,0x4e,0x6f,0x62,0x6d,0x39,0x73,0x62,0x32,0x64,0x70,0x5a,0x58,0x4d,0x67,0x53,0x57,0x35,0x6a,0x4d,0x52,0x30,0x77,0x47,0x77,0x59,0x44,0x0a,
0x56,0x51,0x51,0x4c,0x44,0x42,0x52,0x50,0x62,0x6e,0x6c,0x34,0x56,0x48,0x5a,0x54,0x64,0x48,0x56,0x6b,0x61,0x57,0x38,0x72,0x64,0x6d,0x56,0x79,0x63,0x32,0x6c,0x76,0x62,0x6a,0x43,0x43,0x41,0x53,0x49,0x77,0x44,0x51,0x59,0x4a,0x4b,0x6f,0x5a,0x49,0x68,0x76,0x63,0x4e,0x41,0x51,0x45,0x42,0x42,0x51,0x41,0x44,0x67,0x67,0x45,0x50,0x0a,
0x41,0x44,0x43,0x43,0x41,0x51,0x6f,0x43,0x67,0x67,0x45,0x42,0x41,0x4d,0x42,0x42,0x57,0x68,0x4e,0x64,0x44,0x6b,0x7a,0x66,0x4f,0x35,0x4f,0x2f,0x4e,0x31,0x47,0x72,0x30,0x46,0x73,0x73,0x44,0x2b,0x39,0x41,0x6f,0x4f,0x42,0x30,0x62,0x42,0x79,0x72,0x50,0x7a,0x6f,0x4e,0x7a,0x67,0x4c,0x6f,0x78,0x71,0x4f,0x39,0x38,0x6b,0x49,0x58,0x0a,
0x61,0x42,0x55,0x6a,0x4e,0x6e,0x67,0x61,0x74,0x65,0x42,0x58,0x37,0x72,0x4b,0x4a,0x61,0x35,0x56,0x44,0x75,0x31,0x70,0x34,0x47,0x2f,0x50,0x4e,0x31,0x42,0x4a,0x59,0x4a,0x34,0x46,0x56,0x39,0x4b,0x72,0x47,0x68,0x30,0x69,0x61,0x4e,0x48,0x74,0x41,0x49,0x71,0x51,0x6f,0x76,0x49,0x59,0x75,0x31,0x31,0x5a,0x76,0x61,0x58,0x2f,0x6c,0x0a,
0x72,0x69,0x47,0x49,0x4d,0x43,0x7a,0x41,0x53,0x75,0x53,0x62,0x5a,0x51,0x77,0x43,0x6e,0x49,0x72,0x68,0x62,0x78,0x67,0x75,0x7a,0x39,0x75,0x7a,0x39,0x72,0x44,0x44,0x68,0x4b,0x48,0x50,0x44,0x77,0x5a,0x78,0x2f,0x54,0x7a,0x35,0x41,0x45,0x73,0x79,0x34,0x34,0x56,0x2b,0x41,0x4f,0x6a,0x35,0x39,0x39,0x35,0x37,0x49,0x32,0x56,0x2b,0x0a,
0x2b,0x48,0x48,0x76,0x39,0x61,0x44,0x70,0x38,0x4c,0x44,0x56,0x37,0x6d,0x53,0x4d,0x62,0x6e,0x68,0x43,0x34,0x62,0x43,0x67,0x30,0x6f,0x39,0x54,0x6f,0x43,0x71,0x73,0x6f,0x6f,0x45,0x76,0x58,0x2b,0x57,0x52,0x56,0x6e,0x53,0x4a,0x77,0x39,0x2f,0x5a,0x32,0x65,0x6c,0x69,0x2b,0x6b,0x64,0x48,0x7a,0x49,0x7a,0x44,0x68,0x68,0x2f,0x39,0x0a,
0x2f,0x65,0x39,0x58,0x43,0x45,0x2b,0x77,0x4a,0x7a,0x5a,0x70,0x50,0x78,0x54,0x6d,0x36,0x5a,0x6a,0x35,0x31,0x75,0x77,0x63,0x41,0x30,0x66,0x42,0x52,0x36,0x50,0x79,0x30,0x58,0x56,0x47,0x64,0x46,0x78,0x6f,0x59,0x50,0x36,0x71,0x35,0x54,0x35,0x45,0x42,0x47,0x4c,0x45,0x35,0x38,0x48,0x62,0x36,0x38,0x74,0x39,0x70,0x33,0x76,0x4f,0x0a,
0x30,0x59,0x35,0x61,0x50,0x41,0x62,0x46,0x44,0x32,0x57,0x68,0x2f,0x5a,0x50,0x67,0x39,0x33,0x46,0x51,0x68,0x37,0x6e,0x52,0x41,0x45,0x2f,0x38,0x6d,0x2b,0x48,0x62,0x57,0x42,0x45,0x43,0x41,0x77,0x45,0x41,0x41,0x54,0x41,0x4e,0x42,0x67,0x6b,0x71,0x68,0x6b,0x69,0x47,0x39,0x77,0x30,0x42,0x41,0x51,0x55,0x46,0x41,0x41,0x4f,0x43,0x0a,
0x41,0x51,0x45,0x41,0x51,0x75,0x39,0x76,0x36,0x37,0x39,0x4c,0x47,0x50,0x33,0x79,0x4a,0x72,0x50,0x45,0x38,0x39,0x6e,0x53,0x51,0x70,0x55,0x35,0x73,0x43,0x58,0x37,0x39,0x58,0x31,0x4c,0x78,0x4e,0x67,0x35,0x38,0x55,0x33,0x54,0x62,0x6f,0x57,0x6e,0x33,0x6b,0x6e,0x46,0x48,0x74,0x34,0x52,0x69,0x53,0x4a,0x76,0x74,0x2b,0x46,0x64,0x0a,
0x6e,0x58,0x74,0x79,0x63,0x47,0x72,0x70,0x33,0x64,0x5a,0x73,0x6e,0x2f,0x73,0x79,0x73,0x46,0x52,0x53,0x58,0x70,0x68,0x77,0x54,0x78,0x76,0x70,0x4b,0x61,0x64,0x59,0x33,0x42,0x67,0x6e,0x43,0x4d,0x5a,0x43,0x52,0x54,0x75,0x66,0x37,0x77,0x75,0x75,0x31,0x57,0x6b,0x41,0x34,0x58,0x4e,0x33,0x56,0x4c,0x31,0x6e,0x71,0x45,0x4c,0x55,0x0a,
0x31,0x4e,0x6d,0x33,0x79,0x73,0x45,0x2f,0x6e,0x30,0x63,0x45,0x62,0x76,0x54,0x2b,0x77,0x75,0x72,0x6c,0x4d,0x74,0x4b,0x41,0x4b,0x71,0x72,0x37,0x68,0x57,0x46,0x4f,0x4a,0x2f,0x37,0x45,0x6f,0x55,0x65,0x39,0x31,0x7a,0x34,0x36,0x6e,0x52,0x4d,0x75,0x55,0x4d,0x5a,0x55,0x50,0x39,0x58,0x41,0x4a,0x41,0x64,0x57,0x7a,0x42,0x68,0x4a,0x0a,
0x47,0x63,0x6a,0x34,0x56,0x35,0x54,0x51,0x54,0x52,0x4e,0x41,0x5a,0x79,0x58,0x65,0x71,0x4a,0x4a,0x52,0x55,0x37,0x59,0x65,0x45,0x73,0x7a,0x69,0x77,0x37,0x61,0x30,0x58,0x53,0x45,0x36,0x44,0x54,0x5a,0x34,0x70,0x4c,0x4d,0x59,0x53,0x56,0x55,0x67,0x6f,0x44,0x76,0x39,0x55,0x51,0x62,0x59,0x58,0x56,0x38,0x65,0x36,0x5a,0x79,0x31,0x0a,
0x75,0x59,0x4e,0x4a,0x32,0x68,0x4f,0x62,0x4d,0x68,0x68,0x66,0x2b,0x55,0x59,0x30,0x65,0x68,0x67,0x51,0x72,0x6d,0x30,0x2f,0x41,0x6b,0x59,0x59,0x6e,0x2f,0x49,0x34,0x34,0x70,0x65,0x41,0x35,0x71,0x57,0x46,0x59,0x39,0x75,0x52,0x6f,0x76,0x63,0x48,0x42,0x66,0x64,0x56,0x37,0x32,0x72,0x72,0x58,0x41,0x55,0x32,0x39,0x54,0x32,0x6f,0x0a,
0x74,0x62,0x55,0x4a,0x4a,0x31,0x30,0x41,0x5a,0x66,0x4f,0x78,0x59,0x49,0x38,0x79,0x57,0x69,0x6c,0x43,0x6a,0x62,0x6c,0x6a,0x64,0x51,0x3d,0x3d,0x0a,
0x2d,0x2d,0x2d,0x2d,0x2d,0x45,0x4e,0x44,0x20,0x43,0x45,0x52,0x54,0x49,0x46,0x49,0x43,0x41,0x54,0x45,0x2d,0x2d,0x2d,0x2d,0x2d,0x0a,
0x00
};

int getKeyPair (const char* keyFileName, char** ppKeyBuf)

{
#ifdef  KEY_FORM_FILE
	FILE* f = 0;
	size_t fsize = 0;
	f = fopen(keyFileName, "r");

	if (f != 0)	{
		fseek(f, 0, SEEK_END);
		fsize = ftell(f);
		rewind(f);
		int keyLen = fsize + 1;
		char *keyBuf = new char[keyLen];
		size_t read = fread(keyBuf,1,fsize,f);
		if (read != fsize) 	{ 
			printf("Error reading %s\n", keyFileName);
			return 0;
		};
		keyBuf[fsize]=0; //cert should be null terminated
		fclose(f);
		*ppKeyBuf = keyBuf;
		DumpKey((unsigned char *)keyBuf);
		return keyLen;		
	};
	printf("Error opening app token file: %s\n", keyFileName);
#endif
	return 0;
};


int CSkypeUi::Start()
{
	int res = -1;
	TransportInterface::Status skypeStatus;
	const char *szSkypeRuntimePath = "windows-x86-skypekit.exe";
	CSkypeUi *pSkypeUi = this;

	BOOL fResult = CreateProcessA(szSkypeRuntimePath, NULL, NULL, NULL, FALSE, 
						NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW, NULL, NULL, 
						&pSkypeUi->mStartupInfo, &pSkypeUi->mProcessInformation);

	if (!fResult) {
		dispatcher->SendToLogSignal("ERROR: CreateProcess failed!");
		goto Exit;
	}

	skypeStatus = skype->init((const char *)keyPair, "127.0.0.1", 8963);
	if(skypeStatus != TransportInterface::OK) {
		dispatcher->SendToLogSignal("ERROR: Skype Init failed.!");
		goto Exit;
	}
	if(!skype->start()){
		goto Exit;
	}
	res = 0;
Exit:
	return res;
}

int CSkypeUi::Logout()
{
	int res = -1;
	TransportInterface::Status skypeStatus;
	CSkypeUi *pSkypeUi = this;

	if(skype->Logout()){
		dispatcher->SendToLogSignal("ERROR: Logout failed!");
		goto Exit;
	}
	res = 0;
Exit:
	return res;
}

int CSkypeUi::Login(
	const char *szAccountName,
	const char *szPassword)
{
	int res = -1;
	TransportInterface::Status skypeStatus;
	CSkypeUi *pSkypeUi = this;

    SEString accountName = szAccountName;
    SEString password = szPassword;

	if(skype->Login(szAccountName, szPassword) != 0/*0=success*/){
		dispatcher->SendToLogSignal("ERROR: Login failed. Invalid user id or password!");
		goto Exit;
	}
	// Set returnb result to success
	res = 0;
Exit:
	return res;
}

int CSkypeUi::Stop()
{
	CSkypeUi *pSkypeUi = this;
	
	skype->stop();
	delete skype;

	// TODO: Post Exit Message
	WaitForSingleObject( pSkypeUi->mProcessInformation.hProcess, INFINITE );
	CloseHandle(pSkypeUi->mProcessInformation.hProcess );
	CloseHandle(pSkypeUi->mProcessInformation.hThread );

	return 0;
}

int CSkypeUi::InitSharedMem()
{
	int nErr = 0;
	mMapFile = CreateFileMappingA(
				 INVALID_HANDLE_VALUE,			// use paging file
				 NULL,							// default security
				 PAGE_READWRITE,				// read/write access
				 0,								// maximum object size (high-order DWORD)
				 VID_FRAME_SHARED_BUF_SIZE,		// maximum object size (low-order DWORD)
				 mSharedMemName.c_str());               // name of mapping object

	if (mMapFile != INVALID_HANDLE_VALUE)  {
		mSharedBuf = (LPTSTR) MapViewOfFile(mMapFile, FILE_MAP_ALL_ACCESS, 0,  0, VID_FRAME_SHARED_BUF_SIZE);
		if (mSharedBuf == NULL)  {
			CloseHandle(mMapFile);
		}
	} else {
		nErr = GetLastError();
	}

   if (mSharedBuf == NULL)  {
		DbgOut(DBG_LVL_ERR,("Could not map view of file (%d).\n", GetLastError()));
		CloseHandle(mMapFile);
		nErr = -1;
   }
   return nErr;
}

int CSkypeUi::DeinitShareddMem()
{

	if(mSharedBuf) {
		UnmapViewOfFile(mSharedBuf);
		mSharedBuf = NULL;
	}
	if((mMapFile != INVALID_HANDLE_VALUE)){
		CloseHandle(mMapFile);
		mMapFile = INVALID_HANDLE_VALUE;
	}
	return 0;
}

DWORD WINAPI CSkypeUi::DoBufferProcessing(void *pCtx)
{
	CSkypeUi *pSkype = (CSkypeUi *)pCtx;
	CVideoRx *pVidRx = pSkype->mVidRx;
	
	while(pVidRx && pSkype->mRunMemStream) {
		if(pVidRx->CopyFrameToSharedMem((char *)pSkype->mSharedBuf) != 0){
			// TODO			
		}
		Sleep(30);
	}
	return 0;
}
int CSkypeUi::StartMemStream()
{
	DWORD dwThreadId;
	if(mSharedMemName.size() > 0){
		InitSharedMem();
		mRunMemStream = true;
		mThread = CreateThread(NULL, 0, DoBufferProcessing, 
									this, 0, &dwThreadId );
	}
	return 0;
}

int CSkypeUi::StopMemStream()
{
	mRunMemStream = false;
	if(mThread !=  INVALID_HANDLE_VALUE) {
		WaitForSingleObject( mThread, INFINITE );
		mThread =  INVALID_HANDLE_VALUE;
	}
	DeinitShareddMem();
	return 0;
}

void QSKContact::OnChange(int prop)
{
	if (prop == Contact::P_AVAILABILITY)  {
		SEString name;
		GetPropDisplayname(name);

		Contact::AVAILABILITY availability;
		GetPropAvailability(availability);

		SEString statusAsText;
		statusAsText = tostring(availability);

		//DbgOut(("%s -> %s\n", (const char*)name, (const char*)statusAsText));
  };
};

int CSkypeUi::GetContactList()
{
	QSKContactGroup::Ref skypeNamesContactGroup;
	skype->GetHardwiredContactGroup(ContactGroup::SKYPE_BUDDIES, skypeNamesContactGroup);
	skypeNamesContactGroup->GetContacts(skypeNamesContactGroup->contactList);

	fetch(skypeNamesContactGroup->contactList);
	for (uint i = 0; i < skypeNamesContactGroup->contactList.size(); i++)   {
			SEString contactName;
			skypeNamesContactGroup->contactList[i]->GetPropDisplayname(contactName);
			printf("%3d. %s\n", i+1, (const char*)contactName);
	};
	return 0;
}

void CSkypeUi::on_UpdateStatus(int nStatusId, int whyDidWeLogout)
{
	int nSkypeStatusId = SKYPE_STATUS_UNKNOWN;
	SKYPE_LOGOUT_INF_T LogOutInf = {whyDidWeLogout};
	if(mpCallback){
		switch(nStatusId)
		{
			case Account::LOGGED_OUT: 

				{
					switch(whyDidWeLogout){
					case Account::LOGOUT_CALLED:
						LogOutInf.whyDidWeLogout = SKYPE_LOGOUT_CALLED;
						break;

					case Account::INCORRECT_PASSWORD:
						LogOutInf.whyDidWeLogout = SKYPE_INCORRECT_PASSWORD;
						break;
					case Account::NO_SUCH_IDENTITY:          
						LogOutInf.whyDidWeLogout = SKYPE_INCORRECT_ID;
						break;

					case Account::HTTPS_PROXY_AUTH_FAILED:
					case Account::SOCKS_PROXY_AUTH_FAILED:   
					case Account::P2P_CONNECT_FAILED:        
					case Account::SERVER_CONNECT_FAILED:     
					case Account::SERVER_OVERLOADED:         
					case Account::DB_IN_USE:                 
					case Account::INVALID_SKYPENAME:         
					case Account::INVALID_EMAIL:             
					case Account::UNACCEPTABLE_PASSWORD:
					case Account::SKYPENAME_TAKEN:           
					case Account::REJECTED_AS_UNDERAGE:      
					case Account::TOO_MANY_LOGIN_ATTEMPTS:   
					case Account::PASSWORD_HAS_CHANGED:      
					case Account::PERIODIC_UIC_UPDATE_FAILED:
					case Account::DB_DISK_FULL:              
					case Account::DB_IO_ERROR:               
					case Account::DB_CORRUPT:                
					case Account::DB_FAILURE:                
					case Account::INVALID_APP_ID:            
					case Account::APP_ID_FAILURE:            
					case Account::UNSUPPORTED_VERSION:       
					case Account::ATO_BLOCKED:
						LogOutInf.whyDidWeLogout = SKYPE_LOGOUT_GENERIC;
						break;
					}
				}
				nSkypeStatusId = SKYPE_STATUS_LOGGED_OUT;
				break;
			case Account::LOGGED_OUT_AND_PWD_SAVED:
				nSkypeStatusId = SKYPE_STATUS_LOGGED_OUT_AND_PWD_SAVED;
				break;

			case Account::CONNECTING_TO_P2P:
				nSkypeStatusId = SKYPE_STATUS_CONNECTING_TO_P2P;
				break;

			case Account::CONNECTING_TO_SERVER:
				nSkypeStatusId = SKYPE_STATUS_CONNECTING_TO_SERVER;
				break;

			case Account::LOGGING_IN:    
				nSkypeStatusId = SKYPE_STATUS_LOGGING_IN;
				break;

			case Account::INITIALIZING:
				nSkypeStatusId = SKYPE_STATUS_INITIALIZING;
				break;

			case Account::LOGGED_IN:            
				nSkypeStatusId = SKYPE_STATUS_LOGGED_IN;
				break;

			case Account::LOGGING_OUT:
				nSkypeStatusId = SKYPE_STATUS_LOGGING_OUT;
				break;

		}
		mpCallback->LoginStatus(nSkypeStatusId, (void *)&LogOutInf);
	}
}
void CSkypeUi::on_LiveSessionClosed()
{
	if(mpCallback)
		mpCallback->LiveSessionClosed();

}

void CSkypeUi::on_OtherSessionClosed()
{
	if(mpCallback)
		mpCallback->OtherSessionClosed();
}

int CSkypeUi::EnableAutoAnswer(bool fEnable)
{
	skype->mfAutoAnswer = fEnable;
	return 0;
}


int CSkypeUi::AceptIncomingCall(bool fAccept)
{
	skype->mfAcceptCall = fAccept;
	skype->mfUserActed = true;
	return true;
}
void CSkypeUi::PlaceCall(const char *szCallee)
{
	skype->PlaceCall(szCallee);
}

int CSkypeUi::HangupCall()
{
	if(skype->liveSession && skype->isLiveSessionUp){
		skype->liveSession->LeaveLiveSession();
	} else {
		skype->mfAcceptCall = false;
		skype->mfUserActed = true;
	}
	return 0;
}

int CSkypeUi::UpdateContactList()
{
    skype->GetHardwiredContactGroup(ContactGroup::ALL_KNOWN_CONTACTS, skype->allBuddiesGroup);
    skype->allBuddiesGroup->GetContacts(skype->allBuddies);

    //this->log("Updating contatct list.");
    //this->ui->contactList->clear();    
	// Clear List
	mpCallback->AddContact(NULL);

    skype->GetHardwiredContactGroup(ContactGroup::ALL_KNOWN_CONTACTS, skype->allBuddiesGroup);
    skype->allBuddiesGroup->GetContacts(skype->allBuddies);

    int contactCount = skype->allBuddies.size();
    for (int i = 0; i < contactCount; i++)  {
        SEString contactName;
		SEString contactFullName;
        Contact::TYPE contactType;

        skype->allBuddies[i]->GetPropType(contactType);
        if (contactType == Contact::SKYPE) {
			bool bImgPresent;
			Sid::Binary imageContact;
            skype->allBuddies[i]->GetPropSkypename(contactName);
			skype->allBuddies[i]->GetPropFullname(contactFullName);
			skype->allBuddies[i]->GetAvatar(bImgPresent, imageContact);
			if(mpCallback){
				SKYPE_CONTACT_INF_T ContactInf = {0};
				ContactInf.pszContactName = (const char *)contactName;
				ContactInf.pszContactFullName = (const char *)contactFullName;
				if(bImgPresent) {
					ContactInf.imgJpgData = imageContact.data();
					ContactInf.imgLen = imageContact.size();
				}
				mpCallback->AddContact(&ContactInf);
		   }
		}
	}
	return 0;
};


bool CSkypeUi::IsInAutoReplyList(const char *psContact)
{
	if(mAutoReplyList.size()) {
		if(mAutoReplyList.find(psContact) != std::string::npos)
			return true;
	}
	return false;
}

int CSkypeUi::GetAudioInputDeviceList(char *pszBuff, int nBufSize)
{
	SEStringList inHandles, inNames, inProductIDs;

	// Getting a list of audio input devices.
	DbgOut(DBG_LVL_MSG,("\n** Recording devices:\n"));
	skype->GetAvailableRecordingDevices (inHandles, inNames, inProductIDs);
	for (uint i = 0; i < inHandles.size(); i++)  {
		DbgOut(DBG_LVL_MSG, ("%4d. %s %s\n", i, (const char*)inHandles[i], (const char*)inNames[i]));
		int reqlen = strlen((const char*)inNames[i]);
		reqlen ++; // for new line
		if(nBufSize > reqlen){
			// Append name to list and reduce buffer size
			strcat(pszBuff, (const char*)inNames[i]);
			strcat(pszBuff, "\n");
			nBufSize -= reqlen;
		}
	};
	return inHandles.size();
}

int CSkypeUi::GetAudioOutputDeviceList(char *pszBuff, int nBufSize)
{
	SEStringList outHandles, outNames, outProductIDs;

	// Getting a list of audio input devices.
	DbgOut(DBG_LVL_MSG,("\n** Recording devices:\n"));
	skype->GetAvailableOutputDevices (outHandles, outNames, outProductIDs);
	for (uint i = 0; i < outHandles.size(); i++) {
		DbgOut(DBG_LVL_MSG,("%4d. %s %s\n", i, (const char*)outHandles[i], (const char*)outNames[i]));
		int reqlen = strlen((const char*)outNames[i]);
		reqlen ++; // for new line
		if(nBufSize > reqlen){
			// Append name to list and reduce buffer size
			strcat(pszBuff, (const char*)outNames[i]);
			strcat(pszBuff, "\n");
			nBufSize -= reqlen;
		}
	};
	return outHandles.size();
}

int CSkypeUi::SelectAudioDevices(const char *pszAudInput, const char *pszAudOutput)
{
	SEStringList inHandles, inNames, inProductIDs;
	SEStringList outHandles, outNames, outProductIDs;
	uint micIdx = 0;
	uint spkIdx = 0;
	skype->GetAvailableRecordingDevices (inHandles, inNames, inProductIDs);
	for (micIdx = 0; micIdx < inHandles.size(); micIdx++)  {
		if(	strcmp(pszAudInput, (const char*)inNames[micIdx]) == 0)
			break;
	}
	skype->GetAvailableOutputDevices (outHandles, outNames, outProductIDs);
	for (spkIdx = 0; spkIdx < outHandles.size(); spkIdx++)  {
		if(	strcmp(pszAudOutput, (const char*)outNames[spkIdx]) == 0)
			break;
	}
	DbgOut(DBG_LVL_MSG,("Selecting AudIn=%d Audout=%d\n", micIdx, spkIdx));
	skype->SelectSoundDevices(inHandles[micIdx], outHandles[spkIdx], outHandles[spkIdx]);
	return 0;
}
void SendOnyxDtmfKey( int dtmfKey )
{
	ONYX_MSG_T Msg;
	if(dtmfKey >= 0 && dtmfKey <= 9){
		if(dtmfKey == 0) {
			Msg.v.key.val = OnyxControl::KC_0;
		} else if (dtmfKey >= 1 && dtmfKey <= 9){
			Msg.v.key.val = OnyxControl::KC_1 + dtmfKey - 1;
		}
		Msg.Id = ONYX_MSG_KEY;
		ocntrlPostMsg(&Msg);
	}
}
