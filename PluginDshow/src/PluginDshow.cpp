/*
-----------------------------------------------------------------------------
Filename:    PluginDshow.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC9 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "PluginDshow.h"

#define PLUGIN_TYPE "ds_video"		// texture_source of material

int nextPow2(int x)
{
	int y;
	for (y=1;y<x;y*=2);
	return y;
}

class ManualTimer : public Timer
{
public:
	void update(float t)
	{
	
	}

	void setTime(float time)
	{
		mTime=time;
	}
};


PluginDshow::PluginDshow(int num_worker_threads) : VideoManager(/*num_worker_threads*/)
{
#ifdef OGRE_1_7_1
	mPlugInName = "DsVideoPlugin";
	mDictionaryName = mPlugInName;
#else
	mPluginName = "DsVideoPlugin";
	mDictionaryName = mPluginName;
#endif
	mbInit = false;
	mUpsideDown = false;
	mTechniqueLevel=mPassLevel=mStateLevel=0;
	mStrmStatus = -1;
	mVertCropPercent = 0;
	mHorzCropPercent = 0;
	mCapWidth = 640;
	mCapHeight = 480;

	initialise();
}

bool PluginDshow::initialise()
{
	if (mbInit) return false;
	mbInit=true;
	addBaseParams(); // ExternalTextureSource's function
	return true;
}

PluginDshow::~PluginDshow()
{
	shutDown();
}

void PluginDshow::shutDown()
{
	if (!mbInit) return;

	mbInit=false;
}

bool PluginDshow::setParameter(const Ogre::String &name,const Ogre::String &value)
{
	const char *pParamName = name.c_str();

	if(strcmp(pParamName, KEY_NAME_SELECT_BY_TEXTURE) == 0){
		mTextureName = value;
		goto DefaultProc;
	}	else if(strcmp(pParamName, KEY_NAME_UPDATE_INPUT) == 0){
		VideoClip* pClip = getVideoClipByTextureName(mTextureName);	
		mTextureName = value;
		mMaterialName = value;
		if(pClip) destroyVideoClip(pClip);

		pClip = createVideoClip(mInputFileName,TH_ARGB,0,1, mHorzCropPercent, mVertCropPercent, mCapWidth, mCapHeight);
		if(pClip) {
			pClip->mMaterialName = mMaterialName;
			pClip->mTextureName = mTextureName;	// Use material name for now
			pClip->setColorKeyValue(mColorKeyEnable, mColorKeyRatio, mColorKeyThresh);
			pClip->setUpsideDown(mUpsideDown);
			pClip->play();
		}
		goto DefaultProc;
	}  else if(strcmp(pParamName, KEY_NAME_CLOSE_INPUT) == 0){
		VideoClip* pClip = getVideoClipByTextureName(mTextureName);	
		mTextureName = value;
		mMaterialName = value;
		if(pClip) destroyVideoClip(pClip);
		goto DefaultProc;
	}

	VideoClip* pClip = getVideoClipByTextureName(mTextureName);	
	
	if(strcmp(pParamName, KEY_NAME_COLORKEY_RATIO) == 0){
		sscanf(value.c_str(),"%d",&mColorKeyRatio);
		if(pClip) pClip->setColorKeyValue(mColorKeyEnable, mColorKeyRatio, mColorKeyThresh);

	} else if(strcmp(pParamName, KEY_NAME_COLORKEY_THRESH) == 0){
		sscanf(value.c_str(),"%d",&mColorKeyThresh);
		if(pClip) pClip->setColorKeyValue(mColorKeyEnable, mColorKeyRatio, mColorKeyThresh);
	} else if(strcmp(pParamName, KEY_NAME_STREAM_COLORKEY_ENABLE) == 0){
		sscanf(value.c_str(),"%d",&mColorKeyEnable);
		if(pClip) pClip->setColorKeyValue(mColorKeyEnable, mColorKeyRatio, mColorKeyThresh);
	} else if(strcmp(pParamName, KEY_NAME_UPSIDEDOWN) == 0){
		sscanf(value.c_str(),"%d",&mUpsideDown);
		if(pClip) pClip->setUpsideDown(mUpsideDown);
	} else if(strcmp(pParamName, KEY_NAME_PLAY) == 0){
		// Issue Play to the current clip
		if(pClip) pClip->play();
	} else if(strcmp(pParamName, KEY_NAME_PAUSE) == 0){
		// Issue Pause to the current clip
		if(pClip) pClip->pause();
	} else if(strcmp(pParamName, KEY_NAME_RESTART) == 0){
		// Issue Pause to the current clip
		if(pClip) pClip->restart();
	} else if(strcmp(pParamName, KEY_NAME_MOVEUP) == 0){
		if(pClip) pClip->moveUp();
	} else if(strcmp(pParamName, KEY_NAME_MOVEDN) == 0){
		if(pClip) pClip->moveDn();
	} else if(strcmp(pParamName, KEY_NAME_MOVERIGHT) == 0){
		if(pClip) pClip->moveRight();
	} else if(strcmp(pParamName, KEY_NAME_MOVELEFT) == 0){
		 if(pClip) pClip->moveLeft();
	} else if(strcmp(pParamName, KEY_NAME_SET_VERTICAL_CROP) == 0){
		sscanf(value.c_str(),"%d",&mVertCropPercent);
	} else if(strcmp(pParamName, KEY_NAME_SET_HORIZONTAL_CROP) == 0){
		sscanf(value.c_str(),"%d",&mHorzCropPercent);
	} else if(strcmp(pParamName, KEY_NAME_SET_CAP_WIDTH) == 0){
		sscanf(value.c_str(),"%d",&mCapWidth);
	} else if(strcmp(pParamName, KEY_NAME_SET_CAP_HEIGHT) == 0){
		sscanf(value.c_str(),"%d",&mCapHeight);
	} else if(strcmp(pParamName, KEY_NAME_STOP) == 0){
		// Issue Stop to the current clip
		if(pClip) pClip->stop();
	} 
DefaultProc:
	return ExternalTextureSource::setParameter(name, value);
}

Ogre::String PluginDshow::getParameter(const Ogre::String &name) const
{
	if(strcmp(name.c_str(), KEY_NAME_CMD_STATUS) == 0){
		if(mStrmStatus == 0) {
			return KEY_NAME_STATUS_OK;
		} else {
			return KEY_NAME_STATUS_FAIL;
		}
	}
    //return ExternalTextureSource::getParameter(name);
}

void PluginDshow::createDefinedTexture(const Ogre::String& material_name,const Ogre::String& group_name)
{
	std::string name=mInputFileName;
	logMessage("createDefinedTexture:" + mInputFileName);

	VideoClip* clip = createVideoClip(mInputFileName,TH_ARGB,0,1, mHorzCropPercent, mVertCropPercent, mCapWidth, mCapHeight);
	if(clip != NULL) {
		clip->mMaterialName = material_name;
		clip->mTextureName = material_name;	// Use material name for now

		int w=nextPow2(clip->getCropWidth()),h=nextPow2(clip->getCropHeight());
		Ogre::TexturePtr t = Ogre::TextureManager::getSingleton().createManual(clip->mTextureName,group_name,Ogre::TEX_TYPE_2D,w,h,1,0,Ogre::PF_A8R8G8B8,Ogre::TU_DYNAMIC_WRITE_ONLY);
		
		if (t->getFormat() != Ogre::PF_A8R8G8B8) {
			logMessage("ERROR: Pixel format is not PF_A8R8G8B8 which is what was requested!");
		}
		// clear it to black

		unsigned char* texData=(unsigned char*) t->getBuffer()->lock(Ogre::HardwareBuffer::HBL_DISCARD);
		memset(texData,0x00,w*h*4);
		t->getBuffer()->unlock();
		mTextures[clip->mTextureName] = t;

		// attach it to a material
		Ogre::MaterialPtr material = Ogre::MaterialManager::getSingleton().getByName(material_name);
		Ogre::TextureUnitState* ts = material->getTechnique(mTechniqueLevel)->getPass(mPassLevel)->getTextureUnitState(mStateLevel);

		//Now, attach the texture to the material texture unit (single layer) and setup properties
		ts->setTextureName(clip->mTextureName,Ogre::TEX_TYPE_2D);
		ts->setTextureFiltering(Ogre::FO_LINEAR, Ogre::FO_LINEAR, Ogre::FO_NONE);
		ts->setTextureAddressingMode(Ogre::TextureUnitState::TAM_BORDER);
		//ts->setTextureBorderColour(Ogre::ColourValue(0,0,255));

		// scale tex coords to fit the 0-1 uv range
		Ogre::Matrix4 mat=Ogre::Matrix4::IDENTITY;
		mat.setScale(Ogre::Vector3((float) clip->getCropWidth()/w, (float) clip->getCropHeight()/h,1));
		ts->setTextureTransform(mat);
		
		clip->setColorKeyValue(mColorKeyEnable, mColorKeyRatio, mColorKeyThresh);
		clip->setUpsideDown(mUpsideDown);
		clip->play();
	} else {
		logMessage("Failed createDefinedTexture:" + mInputFileName);
	}
}

void PluginDshow::AdjustTextureIfNeeded(VideoClip *pStrm,	Ogre::TexturePtr pTexture)
{
	int srcWidth = pStrm->getCropWidth();
	int srcHeight = pStrm->getCropHeight();
	int srcStride =  nextPow2(srcWidth);
	int srcHeightPow2 =  nextPow2(srcHeight);
	int destWidth = pTexture->getWidth();
	int destHeight = pTexture->getHeight();

	if(destWidth != srcStride || destHeight != srcHeightPow2) {
		pTexture->freeInternalResources();
		pTexture->setWidth(srcStride);
		pTexture->setHeight(srcHeightPow2);
		pTexture->createInternalResources();

		// attach it to a material
		Ogre::MaterialPtr material = Ogre::MaterialManager::getSingleton().getByName(pStrm->mTextureName);
		Ogre::TextureUnitState* ts = material->getTechnique(mTechniqueLevel)->getPass(mPassLevel)->getTextureUnitState(mStateLevel);

		// scale tex coords to fit the 0-1 uv range
		Ogre::Matrix4 mat=Ogre::Matrix4::IDENTITY;
		float sx = (float)srcWidth/srcStride;
		float sy = (float)srcHeight/srcHeightPow2;
		mat.setScale(Ogre::Vector3(sx, (float)sy,1));
		ts->setTextureTransform(mat);
	}
}

void PluginDshow::destroyAdvancedTexture(const Ogre::String& sTextureName,const Ogre::String& groupName)
{
	VideoClip* pClip = getVideoClipByTextureName(sTextureName);
	if(pClip) {
		std::map<std::string,Ogre::TexturePtr>::iterator it;
		it = mTextures.find(sTextureName);
		Ogre::TexturePtr t = it->second;//mTextures[sTextureName];
		mTextures.erase(it);
		if(!t.isNull()) {
			t->freeInternalResources();
			Ogre::TextureManager::getSingleton().remove(sTextureName);
		}
		destroyVideoClip(pClip);
	}
}

bool PluginDshow::frameStarted(const Ogre::FrameEvent& evt)
{
	// update playing videos
	std::list<VideoClip*>::iterator it;
	VideoFrame* f;
	for (it=mClips.begin();it!=mClips.end();it++) {
		f=(*it)->getNextFrame();
		if (f) 	{
			
			int w=f->getStride(),h=f->getHeight();
			Ogre::TexturePtr t = mTextures[(*it)->getTextureName()];
			AdjustTextureIfNeeded(*it, t);

			unsigned char *texData=(unsigned char*) t->getBuffer()->lock(Ogre::HardwareBuffer::HBL_DISCARD);
			unsigned char *videoData=f->getBuffer();

			memcpy(texData,videoData,w*h*4);

			t->getBuffer()->unlock();
			(*it)->popFrame();
			mTotalFrames++;
		}
	}
	return true;
}

//=============================================================================

PluginDshow *pPluginDshow;
OGREVIDEO_EXPORT void dllStartPlugin()
{
	//VideoManager::setLogFunction(ogrevideo_log);
	// Create our new External Texture Source PlugIn
	pPluginDshow = new PluginDshow();

	// Register with Manager
	Ogre::ExternalTextureSourceManager::getSingleton().setExternalTextureSource(PLUGIN_TYPE,pPluginDshow);
	Ogre::Root::getSingleton().addFrameListener(pPluginDshow);
}

OGREVIDEO_EXPORT void dllStopPlugin()
{
	Ogre::Root::getSingleton().removeFrameListener(pPluginDshow);
	delete pPluginDshow;
}
