/*
-----------------------------------------------------------------------------
Filename:    OnyxVirtualStudio.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC9 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "OnyxVirtualStudio.h"
#include <OgreConfigFile.h>
#include "PluginDShowParams.h"
#include "PluginParams.h"
#include "HexagonalLayout.h"
#include "CylindricalLayout.h"
#include "PanoramicLayout.h"

#include "CaptureGraph.h"
#include "OnyxControl.h"
#include "SharedmemIf.h"
#include "Msi.h"

const int modelDepth  = 320;

#define   MAX_CROP_RATIO   0.3

#define EVALUTION_COPY

#ifdef WIN32
#include <Shlobj.h>
#include <Knownfolders.h>
#endif
void GetConfigFoderPath(std::string &cfgFolderPath)
{
#ifdef WIN32
#if 0 //#ifdef _DEBUG
	cfgFolderPath = ".";
#else
    const int MAX_STRINGZ=500;
    static char ctext[MAX_STRINGZ+2];
	PWSTR romingFolder = NULL; 
	SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, NULL, &romingFolder);
	WideCharToMultiByte(CP_ACP, 0, romingFolder, -1, ctext, MAX_STRINGZ,0,0);
	std::string path = ctext;
	CoTaskMemFree(romingFolder);
	cfgFolderPath = path + "\\MCN\\Onyx Virtual Studio Elite";
#endif
#else
	cfgFolderPath = ".";
#endif
}

#define EVAL_PANEL          "EvalPanel"
#define EVAL_COPY            "EvalCopy"
#define CUSTOM_NONE			0
#define CUSTOM_TEAM_ZOOM	1

//const char *ProductCode = "{45AB35EE-E471-49ED-B5C4-A51CA63E804B}";
const char *ProductCode = "{5DACF97A-8CC6-4496-9487-80C4059AD94A}";

//                          ####-##%%-%%##-####>
const char *EvalCode =     "4564-9888-1474-7789";
const char *TeamZoomCode = "5647-9811-1491-3421";
const char *ProdCodeAllZeros  = "0000-0000-0000-0000";
const char *ProdCodeAll7s     = "7777-7777-7777-7777";
//-------------------------------------------------------------------------------------
int CStream::streamType()
{
	if(mVideoStream.find("@skype")  != std::string::npos)
		return STRM_TYPE_SKYPE_IN; //STRM_TYPE_DS_PLAY;
	else if(mVideoStream.find(KEY_NAME_SKYPE_VIDEO)  != std::string::npos)
		return STRM_TYPE_EXT_VIDIN;
	else
		return STRM_TYPE_DS_PLAY;
}

void CMcnVCamIf::Init(
			OnyxVirtualStudio *pParent, 
			Ogre::Camera *pCamera,
			const char   *vcamName,
			int          nWidth,
			int          nHeight)
{
	unsigned long ulErr = 0;
	Ogre::TexturePtr rtt_texture = Ogre::TextureManager::getSingleton().createManual("VCam", 
					Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
					Ogre::TEX_TYPE_2D, nWidth, nHeight, 0, 
					Ogre::PF_A8R8G8B8, Ogre::TU_RENDERTARGET);
	mRenderTexture = rtt_texture->getBuffer()->getRenderTarget();
	 
	mRenderTexture->addViewport(pCamera);
	mRenderTexture->getViewport(0)->setClearEveryFrame(true);
	mRenderTexture->getViewport(0)->setBackgroundColour(Ogre::ColourValue::Black);
	mRenderTexture->getViewport(0)->setOverlaysEnabled(false);

	mMapFile = CreateFileMapping(
				 INVALID_HANDLE_VALUE,    // use paging file
				 NULL,                    // default security
				 PAGE_READWRITE,          // read/write access
				 0,                       // maximum object size (high-order DWORD)
				 VID_FRAME_SHARED_BUF_SIZE,    // maximum object size (low-order DWORD)
				 vcamName);               // name of mapping object

	if (mMapFile != NULL)  {
		mSharedBuf = (LPTSTR) MapViewOfFile(mMapFile,   // handle to map object
							FILE_MAP_ALL_ACCESS, // read/write permission
							0,
							0,
							VID_FRAME_SHARED_BUF_SIZE);
	} else {
		ulErr = GetLastError();
	}

	mPixelBox = new Ogre::PixelBox(nWidth, nHeight, 1, Ogre::PF_A8R8G8B8);
	//mPixelBox->data = malloc(1024 * 1024 * 4);
	mPixelBox->data = OGRE_ALLOC_T(unsigned char, mPixelBox->getWidth() * mPixelBox->getHeight() * 4, Ogre::MEMCATEGORY_RENDERSYS);
	mRenderTexture->setAutoUpdated(true);
	mRenderTexture->addListener(this);
	mParent = pParent;
}

CMcnVCamIf::~CMcnVCamIf()
{
	if(mSharedBuf)
		UnmapViewOfFile(mSharedBuf);
	if(mMapFile)
		CloseHandle(mMapFile);
	if(mRenderTexture) {
		mRenderTexture->removeAllListeners();
	}
}

void CMcnVCamIf::preRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)
{
	Ogre::RenderTargetListener::preRenderTargetUpdate(evt);
}


void CMcnVCamIf::postRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)
{
	if(mRenderTexture) {
		mRenderTexture->copyContentsToMemory(*mPixelBox, Ogre::RenderTarget::FB_AUTO);
		if(mSharedBuf) {
			MCN_VID_FRAME_T *pFrm = (MCN_VID_FRAME_T *)mSharedBuf;
			int nSize = mPixelBox->getWidth() * mPixelBox->getHeight() * 4;
			//if(pFrm->fInUse == 0) 
			{
				memcpy(mSharedBuf + sizeof(MCN_VID_FRAME_T),(char *)mPixelBox->data, nSize );
				pFrm->width = mPixelBox->getWidth();
				pFrm->height  = mPixelBox->getHeight();
				pFrm->fReady  = 1;
				pFrm->stride = mPixelBox->getWidth();
				pFrm->bitsperPixel = 32;
				pFrm->nFrameNumber++;
			}
		}
	}
	Ogre::RenderTargetListener::postRenderTargetUpdate(evt);
}

//-------------------------------------------------------------------------------------
int SelectPlugin(int nPluginType)
{
	if(nPluginType == STRM_TYPE_EXT_VIDIN) {
		Ogre::ExternalTextureSourceManager::getSingleton().setCurrentPlugIn( PLUGIN_EXT_VIDIN );
	} else {
		Ogre::ExternalTextureSourceManager::getSingleton().setCurrentPlugIn( PLUGIN_DS_VIDEO );
	}
	return 0;
}

int InitMaterialForVideoPlane(CStream &Stream)
{
	int res = -1;
	Ogre::MaterialManager& lMaterialManager = Ogre::MaterialManager::getSingleton();
	Ogre::MaterialPtr lMaterial = lMaterialManager.create(Stream.mMaterial, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	Ogre::Technique* lFirstTechnique = lMaterial->getTechnique(0);
	Ogre::Pass* lFirstPass = lFirstTechnique->getPass(0);
	lFirstPass->setLightingEnabled(false);

	if(Stream.mEnableColorKey) {
		lFirstPass->setSceneBlending (Ogre::SBT_TRANSPARENT_ALPHA);
		lFirstPass->setDepthWriteEnabled(false);
		//lFirstPass->setAlphaRejectSettings (Ogre::CMPF_GREATER_EQUAL, 128);
		//lFirstPass->setCullingMode (Ogre::CULL_NONE);
		//lFirstPass->setManualCullingMode (Ogre::MANUAL_CULL_NONE);
	}

	Ogre::TextureUnitState* lTextureUnit = lFirstPass->createTextureUnitState();
	lTextureUnit->setTextureCoordSet(0);
	res =  0;
	return res;
}

int EnableAlphaBlending(CStream &Stream, bool fEnable)
{
	Ogre::MaterialPtr material = Ogre::MaterialManager::getSingleton().getByName(Stream.mMaterial);
	if(!material.isNull()) {
		Ogre::Pass* lFirstPass = material->getTechnique(0)->getPass(0);
		if(lFirstPass) {
			if(fEnable) {
				lFirstPass->setSceneBlending (Ogre::SBT_TRANSPARENT_ALPHA);
				lFirstPass->setDepthWriteEnabled(false);
			} else {
				lFirstPass->setSceneBlending (Ogre::SBT_REPLACE);
				lFirstPass->setDepthWriteEnabled(true);
			}
		}
	}
	return 0;
}

int OnyxVirtualStudio::InitDsVideo(CStream &Stream)
{
	int res = -1;
	if(Stream.mVideoStream.empty() || Stream.mVideoStream.compare(KEY_NAME_NO_VIDEO) == 0) {
		// Skip processing
	} else  {
		SelectPlugin(Stream.streamType());
		Ogre::ExternalTextureSource *pPlugin = Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn();
		if(pPlugin) {
			pPlugin->setInputName(Stream.mVideoStream);
			pPlugin->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);

			if(!Stream.mAudioStream.empty()) {
				pPlugin->setParameter(KEY_NAME_STREAM_AUDIO, Stream.mAudioStream);
			}

			pPlugin->setParameter(KEY_NAME_COLORKEY_RATIO, Ogre::StringConverter::toString(Stream.mColorKeyRatio));
			pPlugin->setParameter(KEY_NAME_COLORKEY_THRESH, Ogre::StringConverter::toString(Stream.mColorKeyThresh));
			pPlugin->setParameter(KEY_NAME_STREAM_COLORKEY_ENABLE, Ogre::StringConverter::toString(Stream.mEnableColorKey));
			pPlugin->setParameter(KEY_NAME_UPSIDEDOWN, Ogre::StringConverter::toString(Stream.mUpsideDown));
#ifdef CROP_IN_PLUGIN
			pPlugin->setParameter(KEY_NAME_SET_VERTICAL_CROP, Ogre::StringConverter::toString(Stream.mVertCropPercent));
			pPlugin->setParameter(KEY_NAME_SET_HORIZONTAL_CROP, Ogre::StringConverter::toString(Stream.mHorzCropPercent));
#endif
			pPlugin->setParameter(KEY_NAME_SET_CAP_WIDTH, Ogre::StringConverter::toString(Stream.mCapWidth));
			pPlugin->setParameter(KEY_NAME_SET_CAP_HEIGHT, Ogre::StringConverter::toString(Stream.mCapHeight));

			Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);

			pPlugin->createDefinedTexture( Stream.mMaterial );

			// TODO: Get Status
			Stream.mInit = true;
			Stream.mPlayStatus = STATUS_RUN;
			res = 0;
		}
	}
	return res;
}

void OnyxVirtualStudio::DeinitDsVideo(CStream &Stream)
{
	if(Stream.mInit) {
			// TODO: Get Status
		Stream.mInit = false;
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->destroyAdvancedTexture( Stream.mMaterial );
		Stream.mPlayStatus = STATUS_UNINIT;
	}
}

void getStreamList(
	Ogre::ConfigFile      &cfg,
	const char*           prefixStreamId,
	std::vector<CStream>  &listStreams,
	int                   nMaxStreams
	)
{
	char StrmName[128] = {0};
	std::string tmp;

	for (int i = 0; i < nMaxStreams; i++) {
		sprintf(StrmName,"%s%d",prefixStreamId, i+1);
		CStream strStream;

		tmp = cfg.getSetting(KEY_NAME_STREAM_VIDEO, StrmName);
#if 0
		if(tmp.size() == 0 || tmp.compare(KEY_NAME_NO_VIDEO) == 0) {
			continue;
		}
#endif		
		std::string alias = cfg.getSetting(KEY_NAME_ALIAS, StrmName);
		if(!alias.empty()) {
			strStream.mMaterial = alias;
			strStream.mAlias = true;
		} else {
			strStream.mVideoStream = cfg.getSetting(KEY_NAME_STREAM_VIDEO, StrmName);
			strStream.mAudioStream = cfg.getSetting(KEY_NAME_STREAM_AUDIO, StrmName);
		}

		tmp = cfg.getSetting(KEY_NAME_STREAM_MATERIAL, StrmName);
		if(tmp.size() > 0 ){
			strStream.mMaterial = cfg.getSetting(KEY_NAME_STREAM_MATERIAL, StrmName);
		} else {
			// No more streams.
			break;
		}
		tmp = cfg.getSetting(KEY_NAME_STREAM_MATERIAL, StrmName);
		if(tmp.size() > 0 ){
			strStream.mEntityName = cfg.getSetting(KEY_NAME_STREAM_ENTITY, StrmName);
		}
		tmp = cfg.getSetting(KEY_NAME_ROTATION, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mRoll);
		}

		tmp = cfg.getSetting(KEY_NAME_UPSIDEDOWN, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mUpsideDown);
		}
		tmp = cfg.getSetting(KEY_NAME_SET_HORIZONTAL_CROP, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mHorzCropPercent);
		}
		tmp = cfg.getSetting(KEY_NAME_SET_VERTICAL_CROP, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mVertCropPercent);
		}

		tmp = cfg.getSetting(KEY_NAME_SET_CAP_WIDTH, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mCapWidth);
		}
		tmp = cfg.getSetting(KEY_NAME_SET_CAP_HEIGHT, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mCapHeight);
		}

		tmp = cfg.getSetting(KEY_NAME_STREAM_COLORKEY_ENABLE, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%x",&strStream.mEnableColorKey);
		}

		if(strStream.mEnableColorKey) {
			tmp = cfg.getSetting(KEY_NAME_COLORKEY_RATIO, StrmName);
			if(tmp.size() > 0) {
				sscanf(tmp.c_str(), "%x",&strStream.mColorKeyRatio);
			}

			tmp = cfg.getSetting(KEY_NAME_COLORKEY_THRESH, StrmName);
			if(tmp.size() > 0) {
				sscanf(tmp.c_str(), "%x",&strStream.mColorKeyThresh);
			}
		}
		listStreams.push_back(strStream);
	}
}
void getOutStreamList(
	Ogre::ConfigFile      &cfg,
	const char*           prefixStreamId,
	std::vector<COutStream>  &listStreams,
	int                   nMaxStreams
	)
{
	char StrmName[128] = {0};
	std::string tmp;

	for (int i = 0; i < nMaxStreams; i++) {
		sprintf(StrmName,"%s%d",prefixStreamId, i+1);
		COutStream strStream;

		tmp = cfg.getSetting(KEY_NAME_STREAM_VIDEO, StrmName);
		if(tmp.size() == 0) {
			continue;
		}
		strStream.mVideoStream = cfg.getSetting(KEY_NAME_STREAM_VIDEO, StrmName);

		tmp = cfg.getSetting(KEY_NAME_UPSIDEDOWN, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mUpsideDown);
		}

		tmp = cfg.getSetting(KEY_NAME_WIDTH, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mWidth);
		}

		tmp = cfg.getSetting(KEY_NAME_HEIGHT, StrmName);
		if(tmp.size() > 0) {
			sscanf(tmp.c_str(), "%d",&strStream.mHeight);
		}

		listStreams.push_back(strStream);
	}
}

#define KEY_NAME_FULLSCREEN  "fullscreen"
#define KEY_NAME_LAYOUT      "layout"
#define KEY_NAME_POS         "position"
#define KEY_NAME_SCALE       "scale"
#define KEY_NAME_ORIENT      "orientation"

void OnyxVirtualStudio::saveStreamLayout()
{
	std::string strConfigPath;
	GetConfigFoderPath(strConfigPath);
	std::string LayoutFileName = strConfigPath + "/" + "layout.cfg";
	char szValue[MAX_PATH] = {0};
	std::string tmpStr;
	
	int nFullScreen = mWindow->isFullScreen();
	itoa(nFullScreen,szValue, 10);
	WritePrivateProfileStringA("global", KEY_NAME_FULLSCREEN, szValue,LayoutFileName.c_str());

	int nLayout = mLayout->getLayoutOption();
	itoa(nLayout,szValue, 10);
	WritePrivateProfileStringA("fullscreen", KEY_NAME_LAYOUT, szValue,LayoutFileName.c_str());

	if(mAnchors.size() > 0) {
		Ogre::Entity *ent =  mSceneMgr->getEntity(mAnchors[0].mEntityName);
		Ogre::SceneNode *nodeAnchor = ent->getParentSceneNode();
		Ogre::Vector3 posAnchor = nodeAnchor->getPosition();
		tmpStr = Ogre::StringConverter::toString(posAnchor);
		WritePrivateProfileStringA("anchor1", KEY_NAME_POS,tmpStr.c_str(),LayoutFileName.c_str());
		Ogre::Vector3 scaleAnchor = nodeAnchor->getScale();
		tmpStr = Ogre::StringConverter::toString(scaleAnchor);
		WritePrivateProfileStringA("anchor1",KEY_NAME_SCALE,tmpStr.c_str(),LayoutFileName.c_str());
		Ogre::Quaternion orientAnchor = nodeAnchor->getOrientation();
		tmpStr = Ogre::StringConverter::toString(orientAnchor);
		WritePrivateProfileStringA("anchor1",KEY_NAME_ORIENT,tmpStr.c_str(),LayoutFileName.c_str());
	}
	Ogre::Vector3 pos = mCamera->getPosition();
	tmpStr = Ogre::StringConverter::toString(pos);
	WritePrivateProfileStringA("camera", KEY_NAME_POS,tmpStr.c_str(),LayoutFileName.c_str());
	Ogre::Quaternion orient = mCamera->getOrientation();
	tmpStr = Ogre::StringConverter::toString(orient);
	WritePrivateProfileStringA("camera",KEY_NAME_ORIENT,tmpStr.c_str(),LayoutFileName.c_str());
}


void OnyxVirtualStudio::restoreStreamLayout()
{
	std::string strConfigPath;
	GetConfigFoderPath(strConfigPath);
	std::string LayoutFileName = strConfigPath + "/" + "layout.cfg";
	std::string tmpStr;

	char szValue[MAX_PATH] = {0};
	
	int nLayout = GetPrivateProfileIntA("global", KEY_NAME_LAYOUT, 1,LayoutFileName.c_str());
	mLayout->setLayoutOption(nLayout);

	int nFullScreen = GetPrivateProfileIntA("global", KEY_NAME_FULLSCREEN, 0,LayoutFileName.c_str());
	if(nFullScreen)
		SetFullScreenNoCaption(nFullScreen);

	if(mAnchors.size() > 0) {
		Ogre::Entity *ent =  mSceneMgr->getEntity(mAnchors[0].mEntityName);
		Ogre::SceneNode *nodeAnchor = ent->getParentSceneNode();

		GetPrivateProfileStringA("anchor1", KEY_NAME_POS,"",szValue,MAX_PATH - 1,LayoutFileName.c_str());
		if(strlen(szValue)) {
			Ogre::Vector3 posAnchor = Ogre::StringConverter::parseVector3(szValue);
			nodeAnchor->setPosition(posAnchor);
		}

		GetPrivateProfileStringA("anchor1",KEY_NAME_SCALE,"",szValue,MAX_PATH - 1,LayoutFileName.c_str());
		if(strlen(szValue)) {
			Ogre::Vector3 scaleAnchor = Ogre::StringConverter::parseVector3(szValue);
			nodeAnchor->setScale(scaleAnchor);
		}
		GetPrivateProfileStringA("anchor1",KEY_NAME_ORIENT,"",szValue,MAX_PATH - 1,LayoutFileName.c_str());
		if(strlen(szValue)) {
			Ogre::Quaternion orientAnchor = Ogre::StringConverter::parseQuaternion(szValue);
			nodeAnchor->setOrientation(orientAnchor);
		}
	}

	GetPrivateProfileStringA("camera", KEY_NAME_POS,"",szValue,MAX_PATH - 1,LayoutFileName.c_str());
	if(strlen(szValue)) {
		Ogre::Vector3 pos = Ogre::StringConverter::parseVector3(szValue);
		mCamera->setPosition(pos);
	}
	GetPrivateProfileStringA("camera",KEY_NAME_ORIENT,"",szValue,MAX_PATH - 1,LayoutFileName.c_str());
	if(strlen(szValue)) {
		Ogre::Quaternion orient = Ogre::StringConverter::parseQuaternion(szValue);
		mCamera->setOrientation(orient);
	}
}

// If installation is complete, and product code is not equal to evaluation product id,
// we will treat is as valid invalidation.
bool CheckIfEvalCopy()
{
	DWORD dwBuffLen = 256 - 1;
	char  szBuff[256];
	if(MsiGetProductInfo(ProductCode, "ProductID", szBuff, &dwBuffLen) == ERROR_SUCCESS) {
		if(strcmp(szBuff, EvalCode) == 0 || strcmp(szBuff, ProdCodeAllZeros) == 0 || strcmp(szBuff, ProdCodeAll7s) == 0) {
			return true;
		}
	}
	// Information is not available
	return false;
}

int GetCutomCode()
{
	DWORD dwBuffLen = 256 - 1;
	char  szBuff[256];
	if(MsiGetProductInfo(ProductCode, "ProductID", szBuff, &dwBuffLen) == ERROR_SUCCESS) {
		if(strcmp(szBuff, TeamZoomCode) == 0) {
			return CUSTOM_TEAM_ZOOM;
		}
	}
	// Information is not available
	return CUSTOM_NONE;
}


void OnyxVirtualStudio::getGraphicsConfig(
	Ogre::ConfigFile      &cfg
	)
{
	std::string Section = "Rendering";
	std::string tmp = "RenderSystem";
	tmp = cfg.getSetting(KEY_NAME_GRAPHICS_MANUAL_CONFIG, Section);
	if(tmp.size() > 0) {
		sscanf(tmp.c_str(), "%d",&this->mfUseManualConfig);
	}
	tmp = cfg.getSetting(KEY_NAME_GRAPHICS_SYSTEM, Section);
	if(!tmp.empty()) {
		mRenderingSystem = tmp;	
	}

	tmp = cfg.getSetting(KEY_NAME_GRAPHICS_VIDEO_MODE, Section);
	if(!tmp.empty()) {
		mVideoMode = tmp; 
	}
	
	tmp = cfg.getSetting(KEY_NAME_GRAPHICS_FULL_SCREEN, Section);
	if(!tmp.empty()) {
		mFullScreen = tmp;
	}
	
}

OnyxVirtualStudio::OnyxVirtualStudio(void):
			mOverlay(NULL)
{
	int i;
	std::string strConfigPath;
	GetConfigFoderPath(strConfigPath);
	mOVSConfigFileName = strConfigPath + "/" + "ovs.cfg";
	Ogre::ConfigFile cfg;
    try {
        // Don't trim whitespace
        cfg.load(mOVSConfigFileName, "\t:=", false);
    }
	catch (Ogre::Exception& e)  {
        if (e.getNumber() == Ogre::Exception::ERR_FILE_NOT_FOUND) {
			// Do nothing
        } else {
            throw;
        }
    }
	getStreamList(cfg, "Stream", mStreams, MAX_STREAMS);

	char StrmName[128] = {0};
	getStreamList(cfg, "Advertisement", mAdvertisements, MAX_ADVTS);
	getStreamList(cfg, "Anchor", mAnchors, MAX_ANCHORS);
	getOutStreamList(cfg, "Output", mOutputs, MAX_OUTPUTS);
	mVcamIf = NULL;
	mFocusStream = 0;
	mLayoutId = 0;
	mStichMoveIncrSmall = 1.0 / 1280;
	mStichMoveIncrBig = mStichMoveIncrSmall * 10;
	mStitchVertex = 4;

	mEvalCopy = CheckIfEvalCopy();//true;			// TODO detect
	mCustomCode = GetCutomCode();
	if(mCustomCode == CUSTOM_TEAM_ZOOM){
		// Default cropping for stream 1
		if(mStreams.size() > 0) {
			if(mStreams[0].mHorzCropPercent == 0)
				mStreams[0].mHorzCropPercent = 30;
			if(mStreams[0].mVertCropPercent == 0)
				mStreams[0].mVertCropPercent = 30;
		}
		// Default cropping for stream 2
		if(mStreams.size() > 1) {
			if(mStreams[1].mHorzCropPercent == 0)
				mStreams[1].mHorzCropPercent = 30;
			if(mStreams[1].mVertCropPercent == 0)
				mStreams[1].mVertCropPercent = 30;
		}
	}

	mShiftKeyPressed = false;
	mAltKeyPressed = false;
	mfAligningVideoUp = false;
	mfAligningVideoDn = false;
	mfAligningVideoRight = false;
	mfAligningVideoLeft = false;
	mfCheckBounds = true;
	getGraphicsConfig(cfg);
	mfStatusUpdate = true;
	mAspectRatio = 16.0 / 9.0;
}
//-------------------------------------------------------------------------------------
OnyxVirtualStudio::~OnyxVirtualStudio(void)
{
}

void OnyxVirtualStudio::createOverlay(
			Ogre::String name, 
			Ogre::String material_name,
			float left,
			float top,
			float width,
			float height)

{
	Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
	if(!mOverlay) {
		// Create an overlay
		mOverlay = overlayManager.create( "OverlayAdvt");
	} 
	// Create a panel
	Ogre::OverlayContainer* panel = static_cast<Ogre::OverlayContainer*>( overlayManager.createOverlayElement("Panel", name ));
	panel->setPosition( left, top );
	panel->setDimensions(width,height );
	panel->setMaterialName( material_name );
	// Add the panel to the overlay
	mOverlay->add2D( panel );
 
	// Show the overlay
	mOverlay->show();
}

void OnyxVirtualStudio::createEvalLogo()

{
	float left = 0.0;
	float top = 0.0;
	float width = 1.0;
	float height = 0.1;
	Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
	if(!mOverlay) {
		mOverlay = overlayManager.create( "OverlayAdvt");
	} 
	Ogre::OverlayContainer* panel = static_cast<Ogre::OverlayContainer*>( overlayManager.createOverlayElement("Panel", EVAL_PANEL));
	panel->setPosition( left + 0.02, top + 0.02);
	panel->setDimensions(width, height);
	mOverlay->add2D( panel );
	mOverlay->show();

	Ogre::FontManager::getSingleton().getByName("StarWars")->load();

	Ogre::OverlayElement* textBox = static_cast<Ogre::OverlayElement*>( overlayManager.createOverlayElement("TextArea", EVAL_COPY));
	textBox->setPosition( left, top );
	textBox->setDimensions(width,height );
    textBox->setParameter("font_name", "StarWars");
    textBox->setParameter("char_height", "0.06");
    textBox->setColour(Ogre::ColourValue::White);
 
    textBox->setCaption(mEvalLogo);
	panel->addChild(textBox);

}

void OnyxVirtualStudio::deleteEvalLogo()
{
	Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
	if(mOverlay) {
		Ogre::OverlayContainer* panel = mOverlay->getChild(EVAL_COPY);
		if(panel) {
			panel->removeChild("EvalCopy");
			overlayManager.destroyOverlayElement(EVAL_PANEL);
		}
	}
}

void OnyxVirtualStudio::EnableOverlay(
			Ogre::String name,
			int fEnable)

{
	Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
	Ogre::OverlayElement* panel = static_cast<Ogre::OverlayContainer*>(overlayManager.getOverlayElement(name));
	if(panel) {
		if(fEnable)
			panel->show();
		else
			panel->hide();
	} 
}


void OnyxVirtualStudio::createMovieSphere(
	Ogre::String name, 
	Ogre::String material_name,
	float left,float top,float right,float bottom)
{
    //Ogre::Entity* ogreHead = mSceneMgr->createEntity(name, "Sphere.mesh");
	Ogre::Entity* ogreHead = mSceneMgr->createEntity("Earth", "Earth.mesh");

    Ogre::SceneNode* node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    node->attachObject(ogreHead);
	//node->scale(0.2f, 0.2f, 0.2f);
	node->scale(20.0f, 20.0f, 20.0f);
	ogreHead->setMaterialName(material_name);
}

void OnyxVirtualStudio::setScale(
	Ogre::String     entName, 
	Ogre::Vector3    scale)
{
	Ogre::Entity *ent =  mSceneMgr->getEntity(entName);
	if(ent) {
		Ogre::Node *node = ent->getParentNode();
		if(node){
			node->setScale(scale);
		}
	}
}


void OnyxVirtualStudio::setMovableObject(
	Ogre::String     entName, 
	bool             fVisible)
{
	Ogre::Entity *ent =  mSceneMgr->getEntity(entName);
	if(ent) {
		ent->setVisible(fVisible);
		Ogre::SceneNode *node = ent->getParentSceneNode();
		mFocusObject.setTarget(node);
	}
}

bool OnyxVirtualStudio::getVisible(
	Ogre::String     entName)
{
	Ogre::Entity *ent =  mSceneMgr->getEntity(entName);
	if(ent) {
		return ent->getVisible();
	}
}

bool OnyxVirtualStudio::getPosition(
	Ogre::String     entName,
	Ogre::Vector3    &pos)
{
	Ogre::Entity *ent =  mSceneMgr->getEntity(entName);
	if(ent) {
		Ogre::Node *node = ent->getParentNode();
		if(node){
			pos = node->getPosition();
			return true;
		}
	}
	return false;
}

bool OnyxVirtualStudio::setPosition(
	Ogre::String     entName,
	Ogre::Vector3    &pos)
{
	Ogre::Entity *ent =  mSceneMgr->getEntity(entName);
	if(ent) {
		Ogre::Node *node = ent->getParentNode();
		if(node){
			node->setPosition(pos);
			return true;
		}
	}
	return false;
}


void OnyxVirtualStudio::setCameraPosForStream(int nStream/*base 1*/)
{
	if(nStream == 0){
		mCameraMan->setTarget(NULL);
		mCamera->setPosition(Ogre::Vector3(0,0,240));
		mCamera->lookAt(Ogre::Vector3(0,0,-300));
		mCamera->setNearClipDistance(1);
		mFocusStream = 0;
	} else if (nStream == 9 && !mAnchors.empty()){
		CStream Stream = mAnchors[0/*TODO: Replace with Focus Anchor */];
		if(!Stream.mEntityName.empty() && Stream.mInit){
			if(Stream.mCameraPos == Ogre::Vector3::ZERO){
				setDefaultCameraPosForStream(nStream);
			} else {
				restoreCameraTarget(nStream);
			}
		}
		mFocusStream = 9;
	} else if (nStream > 0 && nStream <= mStreams.size()){
		CStream Stream = mStreams[nStream - 1];
		Ogre::Entity *ent =  mSceneMgr->getEntity(Stream.mEntityName);
		if(ent && Stream.mInit) {
			if(Stream.mCameraPos == Ogre::Vector3::ZERO){
				setDefaultCameraPosForStream(nStream);
			} else {
				restoreCameraTarget(nStream);
			}
			mFocusStream = nStream;
		}
	}
}


void OnyxVirtualStudio::setDefaultCameraPosForStream(int nStream)
{
	if (nStream == 9 && !mAnchors.empty()){
		CStream Stream = mAnchors[0/*TODO: Replace with Focus Anchor */];
		if(!Stream.mEntityName.empty() && Stream.mInit){
			Ogre::Entity *ent =  mSceneMgr->getEntity(Stream.mEntityName);
			if(ent) {
				Ogre::SceneNode *node = ent->getParentSceneNode();
				if(node){
					Ogre::Quaternion Orientation = node->getOrientation();
					// Normal direction
					Ogre::Vector3 Pos = Orientation * Ogre::Vector3::UNIT_Z;
					//mCameraMan->setTarget(node);
					mCamera->setOrientation(Orientation);
					mCamera->setPosition(100 * Pos);
				}
			}
		}
	} else if (nStream > 0 && nStream <= mStreams.size()){
		CStream Stream = mStreams[nStream - 1];
		Ogre::Entity *ent =  mSceneMgr->getEntity(Stream.mEntityName);
		if(ent && Stream.mInit) {
			Ogre::SceneNode *node = ent->getParentSceneNode();
			if(node){
				Ogre::Vector3 nodePos = node->getPosition();
				nodePos.normalise();
				mCamera->setPosition(-modelDepth/2 * nodePos);
				mCamera->lookAt(30 * nodePos);
			}
			mFocusStream = nStream;
		}
	}
}

void OnyxVirtualStudio::AlignAnchorWithCamera()
{
	if (!mAnchors.empty()){
		CStream &Anchor = mAnchors[mFocusAnchor/*TODO: Replace with Focus Anchor */];
		if(Anchor.mAlignWithCamera) {
			Ogre::Entity *ent =  mSceneMgr->getEntity(Anchor.mEntityName);
			if(ent) {
				Ogre::SceneNode *node = ent->getParentSceneNode();
				Ogre::Quaternion  oreintCamera = mCamera->getOrientation(); 
				Ogre::Vector3 posCamera = mCamera->getPosition(); 
				node->setOrientation(oreintCamera);
				Ogre::Vector3 posAnchor = oreintCamera * Anchor.mOffsetFromCamera + posCamera;
				node->setPosition(posAnchor);
				//mLayout->setImageRotation(Anchor.mEntityName, Anchor.mRoll);
				mLayout->SetRotation(Anchor.mEntityName, Anchor.mRoll);
			}
		}
	}
}

void OnyxVirtualStudio::updateAnchorToCameraOffset()
{
	if (!mAnchors.empty()){
		CStream &Anchor = mAnchors[mFocusAnchor/*TODO: Replace with Focus Anchor */];
		Ogre::Entity *ent =  mSceneMgr->getEntity(Anchor.mEntityName);
		if(ent) {
			Ogre::SceneNode *nodeAnchor = ent->getParentSceneNode();
			Ogre::Quaternion  oreintCamera = mCamera->getOrientation(); 
			Ogre::Vector3 posCamera = mCamera->getPosition(); 
			Ogre::Vector3 posAnchor = nodeAnchor->getPosition();
			Anchor.mOffsetFromCamera = oreintCamera.Inverse() * (posAnchor - posCamera);
		}
	}
}

void OnyxVirtualStudio::restoreCameraTarget(int nStream)
{
	if (nStream == 9 && !mAnchors.empty()){
		CStream Stream = mAnchors[0/*TODO: Replace with Focus Anchor */];
		mCamera->setPosition(Stream.mCameraPos);
		mCamera->setDirection(Stream.mCameraDir);
	} else if (nStream > 0 && nStream <= mStreams.size()){
		CStream Stream = mStreams[nStream - 1];
		mCamera->setPosition(Stream.mCameraPos);
		mCamera->setDirection(Stream.mCameraDir);
	}
}

void OnyxVirtualStudio::saveCameraPosForStream(int nStream)
{
	if (nStream == 9 && !mAnchors.empty()){
		CStream &Stream = mAnchors[0/*TODO: Replace with Focus Anchor */];
		Stream.mCameraPos = mCamera->getPosition();
		Stream.mCameraDir = mCamera->getDirection();
	} else if (nStream > 0 && nStream <= mStreams.size()){
		CStream &Stream = mStreams[nStream - 1];
		Stream.mCameraPos = mCamera->getPosition();
		Stream.mCameraDir = mCamera->getDirection();
	}
}

void OnyxVirtualStudio::TogleStreamPlayState()
{
	if(mFocusStream > 0 && mFocusStream <= mStreams.size()) {
		CStream &Stream = mStreams[mFocusStream - 1];
		SelectPlugin(Stream.streamType());

		//Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setInputName(Stream.mVideoStream);
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		Stream.mIsPlaying = !Stream.mIsPlaying;
		if(Stream.mIsPlaying) {
			Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_PLAY, "Play");
			Stream.mPlayStatus = STATUS_RUN;
		} else {
			Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_PAUSE, "Pause");
			Stream.mPlayStatus = STATUS_PUASE;
		}
	}
}

void OnyxVirtualStudio::moveVideoUp()
{
	if(mFocusStream > 0 && mFocusStream <= mStreams.size()) {
		CStream &Stream = mStreams[mFocusStream - 1];
		SelectPlugin(Stream.streamType());
#ifdef CROP_USING_PLUGIN
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_MOVEUP, "1");
#else
		float incr = mShiftKeyPressed ?  mStichMoveIncrSmall : mStichMoveIncrBig;
		mLayout->CropCorner(Stream.mEntityName, mStitchVertex,  0, incr);
#endif
	}
}

void OnyxVirtualStudio::moveVideoDn()
{
	if(mFocusStream > 0 && mFocusStream <= mStreams.size()) {
		CStream &Stream = mStreams[mFocusStream - 1];
		SelectPlugin(Stream.streamType());
#ifdef CROP_USING_PLUGIN
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_MOVEDN, "1");
#else
		float incr = mShiftKeyPressed ?  mStichMoveIncrSmall : mStichMoveIncrBig;
		mLayout->CropCorner(Stream.mEntityName, mStitchVertex,  0, -incr);
#endif
	}
}

void OnyxVirtualStudio::moveVideoRight()
{
	if(mFocusStream > 0 && mFocusStream <= mStreams.size()) {
		CStream &Stream = mStreams[mFocusStream - 1];
		SelectPlugin(Stream.streamType());
#ifdef CROP_USING_PLUGIN
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_MOVERIGHT, "1");
#else
		float incr = mShiftKeyPressed ?  mStichMoveIncrSmall : mStichMoveIncrBig;
		mLayout->CropCorner(Stream.mEntityName, mStitchVertex,  incr, 0.00);
#endif

	}
}
void OnyxVirtualStudio::moveVideoLeft()
{
	if(mFocusStream > 0 && mFocusStream <= mStreams.size()) {
		CStream &Stream = mStreams[mFocusStream - 1];
		SelectPlugin(Stream.streamType());
#ifdef CROP_USING_PLUGIN
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_MOVELEFT, "1");
#else
		float incr = mShiftKeyPressed ?  mStichMoveIncrSmall : mStichMoveIncrBig;
		mLayout->CropCorner(Stream.mEntityName, mStitchVertex,  -incr, 0.00);
#endif
	}
}


void OnyxVirtualStudio::RestartStreamPlay()
{
	if(mFocusStream > 0 && mFocusStream <= mStreams.size()) {
		CStream &Stream = mStreams[mFocusStream - 1];
		SelectPlugin(Stream.streamType());
		//Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setInputName(Stream.mVideoStream);
		Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		if(Stream.mIsPlaying) {
			Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn()->setParameter(KEY_NAME_RESTART, "Restart");
		}
	}
}

void OnyxVirtualStudio::UpdateStreamParam(CStream &Stream, const char *szParam)
{
	SelectPlugin(Stream.streamType());
	Ogre::ExternalTextureSource *pPlugin = Ogre::ExternalTextureSourceManager::getSingleton().getCurrentPlugIn();
	if(pPlugin) {
		// Select Stream
		pPlugin->setParameter(KEY_NAME_SELECT_BY_TEXTURE, Stream.mMaterial);
		if (strcmp(szParam, KEY_NAME_UPSIDEDOWN) == 0) {
			pPlugin->setParameter(KEY_NAME_UPSIDEDOWN, Ogre::StringConverter::toString(Stream.mUpsideDown));
		} else 	if (strcmp(szParam, KEY_NAME_COLORKEY_THRESH) == 0) {
			pPlugin->setParameter(KEY_NAME_COLORKEY_THRESH, Ogre::StringConverter::toString(Stream.mColorKeyThresh));
		} else 	if (strcmp(szParam, KEY_NAME_COLORKEY_RATIO) == 0) {
			pPlugin->setParameter(KEY_NAME_COLORKEY_RATIO, Ogre::StringConverter::toString(Stream.mColorKeyRatio));
		} else 	if (strcmp(szParam, KEY_NAME_STREAM_COLORKEY_ENABLE) == 0) {
			pPlugin->setParameter(KEY_NAME_STREAM_COLORKEY_ENABLE, Ogre::StringConverter::toString(Stream.mEnableColorKey));
		}
	}
}

void OnyxVirtualStudio::UpdateDsVideo(CStream &Stream, CStream &newStream, STREAM_TYPE_T   nStreamType)
{
	// Handle source change
	if(Stream.mVideoStream != newStream.mVideoStream) {
		DeinitDsVideo(Stream);
		if(nStreamType == STREAM_TYPE_ANCHOR || nStreamType == STREAM_TYPE_DISPLAY) {
			mLayout->EnableStream( Stream.mEntityName, Stream.mInit);
		} else {
			EnableOverlay(Stream.mEntityName, Stream.mInit);
		}
		Stream.mVideoStream = newStream.mVideoStream;
		if(InitDsVideo(Stream) == 0){
			if(nStreamType == STREAM_TYPE_ANCHOR || nStreamType == STREAM_TYPE_DISPLAY) {
				mLayout->EnableStream( Stream.mEntityName, Stream.mInit);
				if(nStreamType == STREAM_TYPE_ANCHOR) {
					setMovableObject(Stream.mEntityName, true);
				}
				mLayout->SetCrop(Stream.mEntityName, (float)Stream.mHorzCropPercent / 200.0, (float)Stream.mVertCropPercent / 200.0, (float)Stream.mHorzCropPercent / 200.0, (float)Stream.mVertCropPercent / 200.0);
			} else {
				EnableOverlay(Stream.mEntityName, Stream.mInit);
			}
		}
	} else {

		if (Stream.mColorKeyThresh != newStream.mColorKeyThresh) {
			Stream.mColorKeyThresh = newStream.mColorKeyThresh;
			UpdateStreamParam(Stream, KEY_NAME_COLORKEY_THRESH);
		}

		if (Stream.mColorKeyRatio != newStream.mColorKeyRatio) {
			Stream.mColorKeyRatio = newStream.mColorKeyRatio;
			UpdateStreamParam(Stream, KEY_NAME_COLORKEY_RATIO);
		}
		if (Stream.mEnableColorKey != newStream.mEnableColorKey) {
			Stream.mEnableColorKey = newStream.mEnableColorKey;
			UpdateStreamParam(Stream, KEY_NAME_STREAM_COLORKEY_ENABLE);
			EnableAlphaBlending(Stream, Stream.mEnableColorKey);
		}
		if (Stream.mUpsideDown != newStream.mUpsideDown) {
			Stream.mUpsideDown = newStream.mUpsideDown;
			UpdateStreamParam(Stream, KEY_NAME_UPSIDEDOWN);
		}
		if (Stream.mRoll != newStream.mRoll) {
			Stream.mRoll = newStream.mRoll;
			//mLayout->setImageRotation(Stream.mEntityName, Stream.mRoll);
			mLayout->SetRotation(Stream.mEntityName, Stream.mRoll);
		}
	}
}


float CNodeBounds::UiToOnyx(int nProp, long lVal)
{
	switch(nProp)
	{
	case PROP_POS_X:
		return (mMinX + lVal * (mMaxX - mMinX) / mConvScale);
		break;
	case PROP_POS_Y:
		return (mMinY + lVal * (mMaxY - mMinY) / mConvScale);
		break;
	case PROP_POS_Z:
		return (mMinZ + lVal * (mMaxZ - mMinZ) / mConvScale);
		break;
	case PROP_PITCH:
		return (mMinPitch + lVal * (mMaxPitch - mMinPitch) / mConvScale);
		break;
	case PROP_YAW:
		return (mMinYaw + lVal * (mMaxYaw - mMinYaw) / mConvScale);
		break;
	case PROP_ROLL:
		return (mMinRoll + lVal * (mMaxRoll - mMinRoll) / mConvScale);
		break;
	}
}

 long CNodeBounds::OnyxToUi(int nProp, float fVal)
{
	switch(nProp)
	{
	case PROP_POS_X:
		return ((fVal - mMinX) * mConvScale / (mMaxX - mMinX));
		break;
	case PROP_POS_Y:
		return ((fVal - mMinY) * mConvScale / (mMaxY - mMinY));
		break;
	case PROP_POS_Z:
		return ((fVal - mMinZ) * mConvScale / (mMaxZ - mMinZ));
		break;
	case PROP_PITCH:
		return ((fVal - mMinPitch) * mConvScale / (mMaxPitch - mMinPitch));
		break;
	case PROP_YAW:
		return ((fVal - mMinYaw) * mConvScale / (mMaxYaw - mMinYaw));
		break;
	case PROP_ROLL:
		return ((fVal - mMinRoll) * mConvScale / (mMaxRoll - mMinRoll));
		break;
	}
}

void OnyxVirtualStudio::ExecExternalCmd()
{
	ONYX_MSG_T Msg;
	if(ocntrlGetMsg(&Msg) == 0) {
		switch(Msg.Id)
		{
			case ONYX_MSG_KEY:
			{
				OIS::KeyCode kc = (OIS::KeyCode)Msg.v.key.val;
				OIS::KeyEvent Event(NULL, kc, 0);
				keyPressed(Event);
			}
			break;
			case ONYX_MSG_UPDATE_SOURCE:
			{
				UPDATE_SOURCE_T *ctrlMsgUpdate = &Msg.v.update;
				CStream         newStream;
				STREAM_TYPE_T   nStreamType;
				newStream.mVideoStream = ctrlMsgUpdate->szSource;
				newStream.mEnableColorKey = ctrlMsgUpdate->fEnableColorKey;
				newStream.mColorKeyThresh = ctrlMsgUpdate->ulColorKeyThresh;
				newStream.mColorKeyRatio = ctrlMsgUpdate->ulColorKeyRatio;
				newStream.mRoll = ctrlMsgUpdate->nRotation;
				newStream.mUpsideDown = ctrlMsgUpdate->fUpsideDown;
				CStream *pStream = GetStream(ctrlMsgUpdate->szDisplay, nStreamType);
				if(pStream){
					UpdateDsVideo(*pStream, newStream, nStreamType);
				}
			}
			break;
			case ONYX_MSG_UPDATE_LAYOUT:
			{
				UPDATE_LAYOUT_T *pLayout = &Msg.v.layout;
				mLayout->setLayoutOption(pLayout->ulLayoutId);
			}
			break;
			case ONYX_MSG_UPDATE_WALLPAPER:
			{
				UPDATE_WALLPAPER_T *pWallpaper = &Msg.v.wallpaper;
				mLayout->setThemeOption(pWallpaper->ulWallPaperId);
			}
			break;

			case ONYX_MSG_UPDATE_CROP:
			{
				UPDATE_CROP_T *ctrlMsgCrop = &Msg.v.crop;
				CStream         newStream;
				STREAM_TYPE_T   nStreamType;

				CStream *pStream = GetStream(ctrlMsgCrop->szDisplay, nStreamType);
				if(pStream){
					float fLeft = ctrlMsgCrop->ulCropLeft * MAX_CROP_RATIO / 1000.0;
					float fRight = ctrlMsgCrop->ulCropRight * MAX_CROP_RATIO / 1000.0;
					float fTop = ctrlMsgCrop->ulCropTop * MAX_CROP_RATIO / 1000.0;
					float fBottom = ctrlMsgCrop->ulCropBottom * MAX_CROP_RATIO / 1000.0;
					mLayout->SetCrop(pStream->mEntityName, fLeft,fTop, fRight,fBottom);
				}
			}
			break;
			case ONYX_MSG_NAVIGATE:
			{
				NAVIGATE_T *pNavigate = &Msg.v.navigate;
				switch(pNavigate->ulCtrlId)
				{
					case SCENE_MOVE_DEPTH:
					{
						Ogre::Vector3 pos =  mCamera->getPosition();
						pos.z =  mCamBounds.UiToOnyx(CNodeBounds::PROP_POS_Z, pNavigate->lValue);
						mCamera->setPosition(pos);
					}
					break;
					case SCENE_MOVE_HORZ:
					{
						Ogre::Vector3 pos =  mCamera->getPosition();
						pos.x =  mCamBounds.UiToOnyx(CNodeBounds::PROP_POS_X, pNavigate->lValue);;
						mCamera->setPosition(pos);
					}
					break;
					case SCENE_MOVE_VERT:
					{
						Ogre::Vector3 pos =  mCamera->getPosition();
						pos.y =  mCamBounds.UiToOnyx(CNodeBounds::PROP_POS_Y, pNavigate->lValue);
						mCamera->setPosition(pos);
					}
					break;
					case SCENE_ROTATE_YAW:
					{
						Ogre::Radian pitch, yaw, roll;
						Ogre::Quaternion quat =  mCamera->getOrientation();
						Ogre::Matrix3 mat;
						quat.ToRotationMatrix(mat);

						mat.ToEulerAnglesYXZ(yaw, pitch, roll);
						yaw = Ogre::Radian(mCamBounds.UiToOnyx(CNodeBounds::PROP_YAW, pNavigate->lValue));
						mat.FromEulerAnglesYXZ(yaw, pitch, roll);
						quat.FromRotationMatrix(mat);
						mCamera->setOrientation(quat);
					}
					break;
					case SCENE_ROTATE_PITCH:
					{
						Ogre::Radian pitch, yaw, roll;
						Ogre::Quaternion quat =  mCamera->getOrientation();
						Ogre::Matrix3 mat;
						quat.ToRotationMatrix(mat);

						mat.ToEulerAnglesYXZ(yaw, pitch, roll);
						pitch = Ogre::Radian(mCamBounds.UiToOnyx(CNodeBounds::PROP_PITCH, pNavigate->lValue));
						mat.FromEulerAnglesYXZ(yaw, pitch, roll);
						quat.FromRotationMatrix(mat);
						mCamera->setOrientation(quat);
					}
					break;
					case ANCHOR_SCALE:
					{
						CNodeBounds *pAnchor = &mAnchorBounds[0];
						Ogre::Real scale = pNavigate->lValue / pAnchor->mConvScale;
						mFocusObject.SetProp(CObjectMotion::PROP_SCALE, scale);
					}
					break;
					case ANCHOR_MOVE_DEPTH:
					{
						CNodeBounds *pAnchor = &mAnchorBounds[0];
						Ogre::Real pos_z = pAnchor->UiToOnyx(CNodeBounds::PROP_POS_Z, pNavigate->lValue);
						mFocusObject.SetProp(CObjectMotion::PROP_POS_Z, pos_z);
					}
					break;

					case ANCHOR_MOVE_HORZ:
					{
						CNodeBounds *pAnchor = &mAnchorBounds[0];
						Ogre::Real pos_x = pAnchor->UiToOnyx(CNodeBounds::PROP_POS_X, pNavigate->lValue);
						mFocusObject.SetProp(CObjectMotion::PROP_POS_X, pos_x);
					}
					break;
					case ANCHOR_MOVE_VERT:
					{
						CNodeBounds *pAnchor = &mAnchorBounds[0];
						Ogre::Real pos_y = pAnchor->UiToOnyx(CNodeBounds::PROP_POS_Y, pNavigate->lValue);
						mFocusObject.SetProp(CObjectMotion::PROP_POS_Y, pos_y);
					}
					break;

					case ANCHOR_ROTATE_VERT:
					{
						CNodeBounds *pAnchor = &mAnchorBounds[0];
						float yaw = pAnchor->UiToOnyx(CNodeBounds::PROP_YAW, pNavigate->lValue);
						mFocusObject.SetProp(CObjectMotion::PROP_YAW, yaw);
					}
					break;
					case ANCHOR_HIDE:
					{
						int nHide = pNavigate->lValue;
						if(!mAnchors.empty()){
							if(mAnchors[mFocusAnchor].mInit) {
								setMovableObject(mAnchors[mFocusAnchor].mEntityName ,!nHide);
							}
						}
					}
					break;
					case ANCHOR_LOCK:
					{
						int nLock = pNavigate->lValue;
						CNodeBounds *pAnchor = &mAnchorBounds[0];

						if(!mAnchors.empty()){
							if(mAnchors[mFocusAnchor].mInit) {
								mAnchors[mFocusAnchor].mAlignWithCamera  = (bool)nLock;
								if(nLock)
									updateAnchorToCameraOffset();
							}
						}
					}
					break;
					case LAOYUT_STITCH_PLANE:
					{
						mLayout->mfBoarder = !pNavigate->lValue;
						mLayout->UpdateLayoutOption();
					}
					break;
				}
				
			}
			break;
			case SET_VIEW:
			{
				LOCATION_T *pLocn = &Msg.v.setview.Camera;
				
				mLayout->setLayoutOption(Msg.v.setview.lLayout);
				mLayout->setThemeOption(Msg.v.setview.lWallpaper);
				Ogre::Radian pitch = Ogre::Radian(mCamBounds.UiToOnyx(CNodeBounds::PROP_PITCH, pLocn->lPitch));
				Ogre::Radian yaw = Ogre::Radian(mCamBounds.UiToOnyx(CNodeBounds::PROP_YAW, pLocn->lYaw));
				Ogre::Radian roll = Ogre::Radian(mCamBounds.UiToOnyx(CNodeBounds::PROP_ROLL, pLocn->lRoll));
				Ogre::Quaternion quatCam = Ogre::Quaternion(yaw, Ogre::Vector3::UNIT_Y) * Ogre::Quaternion(pitch, Ogre::Vector3::UNIT_X) * Ogre::Quaternion(roll, Ogre::Vector3::UNIT_Z);
				mCamera->setOrientation(quatCam);

				Ogre::Vector3 pos;
				pos.x = mCamBounds.UiToOnyx(CNodeBounds::PROP_POS_X, pLocn->lPosX);
				pos.y = mCamBounds.UiToOnyx(CNodeBounds::PROP_POS_Y, pLocn->lPosY);
				pos.z = mCamBounds.UiToOnyx(CNodeBounds::PROP_POS_Z, pLocn->lPosZ);
				mCamera->setPosition(pos);
				if(!mLayout->Is2DLayout()) {
					pLocn = &Msg.v.setview.Anchor;
					CNodeBounds *pAnchor = &mAnchorBounds[0];
					pitch = Ogre::Radian(pAnchor->UiToOnyx(CNodeBounds::PROP_PITCH, pLocn->lPitch));
					yaw = Ogre::Radian(pAnchor->UiToOnyx(CNodeBounds::PROP_YAW, pLocn->lYaw));
					roll = Ogre::Radian(pAnchor->UiToOnyx(CNodeBounds::PROP_ROLL, pLocn->lRoll));
					Ogre::Quaternion OrientAnchor = Ogre::Quaternion(yaw, Ogre::Vector3::UNIT_Y) * Ogre::Quaternion(pitch, Ogre::Vector3::UNIT_X) * Ogre::Quaternion(roll, Ogre::Vector3::UNIT_Z);

					pos.x = pAnchor->UiToOnyx(CNodeBounds::PROP_POS_X, pLocn->lPosX);
					pos.y = pAnchor->UiToOnyx(CNodeBounds::PROP_POS_Y, pLocn->lPosY);
					pos.z = pAnchor->UiToOnyx(CNodeBounds::PROP_POS_Z, pLocn->lPosZ);

					mFocusObject.SetLocan(pos, OrientAnchor);
					Ogre::Real scale = pLocn->lScale / pAnchor->mConvScale;
					mFocusObject.SetProp(CObjectMotion::PROP_SCALE, scale);
				}
			}
			break;

		}
	}
}

CStream *OnyxVirtualStudio::GetStream(const char *planeName, STREAM_TYPE_T &nStreamType)
{
	int i;
	/* Create dynamic textures for all the streams */
	int nStreams = mStreams.size();
	for (i=0; i < nStreams; i++){
		if(mStreams[i].mEntityName.compare(planeName) == 0){
			nStreamType = STREAM_TYPE_DISPLAY;
			return &mStreams[i];
		}
	}

	nStreams = mAnchors.size();
	for (i=0; i < nStreams; i++){
		if(mAnchors[i].mEntityName.compare(planeName) == 0){
			nStreamType = STREAM_TYPE_ANCHOR;
			return &mAnchors[i];
		}
	}

	nStreams = mAdvertisements.size();
	for (i=0; i < nStreams; i++){
		if(mAdvertisements[i].mEntityName.compare(planeName) == 0){
			nStreamType =STREAM_TYPE_OVERLAY;
			return &mAdvertisements[i];
		}
	}
	return NULL;
}

void OnyxVirtualStudio::createScene(void)
{
	int planeCount = MAX_STREAMS;
	Ogre::Vector3 pos;
	Ogre::Quaternion orient;
	int nStreams = mStreams.size();

	/* Create dynamic textures for all the streams */
	for (int i=0; i < nStreams; i++){
		if(!mStreams[i].mAlias){
			if (InitMaterialForVideoPlane(mStreams[i]) == 0)
				InitDsVideo(mStreams[i]);
		}
	}

	nStreams = mAnchors.size();
	for (int i=0; i < nStreams; i++){
		if(!mAnchors[i].mAlias){
			if (InitMaterialForVideoPlane(mAnchors[i]) == 0)
				InitDsVideo(mAnchors[i]);
		}
	}

	nStreams = mAdvertisements.size();
	for (int i=0; i < nStreams; i++){
		if(!mAdvertisements[i].mAlias){
			if(InitMaterialForVideoPlane(mAdvertisements[i]) == 0)
				InitDsVideo(mAdvertisements[i]);
		}
	}

	//mLayout = new CHexagonalLayout();
	//mLayout = new CylindricalLayout();
	mLayout = new CPanoramicLayout();
	mLayout->InitLayout(mSceneMgr, planeCount, mAspectRatio, true);

	/* Enable planes that have active textures */
	int nStrmId;
	for (nStrmId = 0;nStrmId < mStreams.size();nStrmId++){
		CStream &Stream = mStreams[nStrmId];
		mLayout->EnableStream( mStreams[nStrmId].mEntityName, mStreams[nStrmId].mInit);
		if(Stream.mRoll > 0){
			//mLayout->setImageRotation(Stream.mEntityName, Stream.mRoll);
			mLayout->SetRotation(Stream.mEntityName, Stream.mRoll);
		}
		mLayout->SetCrop(Stream.mEntityName, (float)Stream.mHorzCropPercent / 200.0, (float)Stream.mVertCropPercent / 200.0, (float)Stream.mHorzCropPercent / 200.0, (float)Stream.mVertCropPercent / 200.0);
	}

	for (nStrmId = 0;nStrmId < mAnchors.size();nStrmId++){
		CStream &Stream = mAnchors[nStrmId];
		mLayout->EnableStream(Stream.mEntityName, Stream.mInit);
		if(Stream.mRoll > 0){
			mLayout->SetRotation(Stream.mEntityName, Stream.mRoll);
		}
		mLayout->SetCrop(Stream.mEntityName, (float)Stream.mHorzCropPercent / 200.0, (float)Stream.mVertCropPercent / 200.0, (float)Stream.mHorzCropPercent / 200.0, (float)Stream.mVertCropPercent / 200.0);
	}
	
	for (nStrmId = 0;nStrmId < mAdvertisements.size();nStrmId++){
		Ogre::Real Top, Left, Width, Height;
		if(mAdvertisements[nStrmId].mInit) {
			mLayout->getAdvPanelPos(nStrmId, Left, Top, Width, Height);
			createOverlay(mAdvertisements[nStrmId].mEntityName, mAdvertisements[nStrmId].mMaterial,
						Left, Top, Width, Height);
		}
	}
	if(mEvalCopy){
		mEvalLogo = "Evaluation Copy";
	} else if(mCustomCode == CUSTOM_TEAM_ZOOM) {
		mEvalLogo = "TeamZoom Test Copy";
	}
	if(mEvalLogo.size() > 0){
		createEvalLogo();
	}
	if(!mAnchors.empty()){
		mFocusAnchor = 0;
		if(mAnchors[mFocusAnchor].mInit) {
			setMovableObject(mAnchors[mFocusAnchor].mEntityName, true);
		}
	}


	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));
    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);

	for (nStrmId = 0;nStrmId < mOutputs.size();nStrmId++){
		COutStream &Stream = mOutputs[nStrmId];
		if(Stream.mVideoStream.size() > 0){
			mVcamIf =  new CMcnVCamIf;
			mVcamIf->Init(this, mCamera, Stream.mVideoStream.c_str(), Stream.mWidth, Stream.mHeight);
		}
	}

	if(mCustomCode == CUSTOM_TEAM_ZOOM){
		restoreStreamLayout();
	}
	mCameraMan->setTopSpeed(10.0);
	mCameraMan->mProjectionSphere.setRadius(mLayout->mProjectionSphere.getRadius()); 

	mCamBounds.SetBounds(-200.0, 200.0, -200.0, 200.0, -180.0, 600.0, 
		-Ogre::Math::PI / 2, Ogre::Math::PI / 2, -Ogre::Math::PI / 2, Ogre::Math::PI / 2,-Ogre::Math::PI / 2, Ogre::Math::PI / 2,
		1000);
	mAnchorBounds[0] = mCamBounds;
}

void OnyxVirtualStudio::destroyScene(void)
{
	int nStreams = mStreams.size();
	for (int i=0; i < nStreams; i++){
		if(!mStreams[i].mAlias){
			DeinitDsVideo(mStreams[i]);
		}
	}
	nStreams = mAnchors.size();
	for (int i=0; i < nStreams; i++){
		if(!mAnchors[i].mAlias){
			DeinitDsVideo(mAnchors[i]);
		}
	}

	nStreams = mAdvertisements.size();
	for (int i=0; i < nStreams; i++){
		if(!mAdvertisements[i].mAlias){
			DeinitDsVideo(mAdvertisements[i]);
		}
	}
	if(mEvalCopy){
		deleteEvalLogo();
	}

	if(mVcamIf) {
		delete mVcamIf;
		mVcamIf = NULL;
	}
}

void OnyxVirtualStudio::UpdateStreamStatus()
{
	std::string playStatus;
	if(mStatusPanel && mStatusPanel->isVisible()) {
		for (int i = 0; i < mStreams.size(); i++) {
			 CStream &Stream = mStreams[i];
			 switch(Stream.mPlayStatus)
			 {
			 case STATUS_UNINIT:
				playStatus = "Not Used";
				break;
			 case STATUS_STOP:
				playStatus = "Stopped";
				break;
			 case STATUS_PUASE:
				playStatus = "Paused";
				break;
			 case STATUS_RUN:
				playStatus = "Running";
				break;

			}
			 mStatusPanel->setParamValue(i, playStatus.c_str());
		}

		for (int i = mStreams.size(); i < MAX_STREAMS; i++) {
			 mStatusPanel->setParamValue(i, "Not Used");
		}

		for (int i = 0; i < mOutputs.size(); i++) {
			 COutStream &Stream = mOutputs[i];
			 switch(Stream.mPlayStatus)
			 {
			 case STATUS_UNINIT:
				playStatus = "Not Used";
				break;
			 case STATUS_STOP:
				playStatus = "Stopped";
				break;
			 case STATUS_PUASE:
				playStatus = "Paused";
				break;
			 case STATUS_RUN:
				playStatus = "Running";
				break;

			}
			mStatusPanel->setParamValue(MAX_STREAMS + 1/*Separator*/ + i, playStatus.c_str());
		}
	}
}

bool OnyxVirtualStudio::keyPressed( const OIS::KeyEvent &arg )
{
#ifdef ENABLE_ONSCREEN_HELP
    if (mTrayMgr->isDialogVisible()) 
		return true;   // don't process any more keys if dialog is up
#endif

	switch(arg.key) {
		case OIS::KC_U:
		case OIS::KC_M:
		case OIS::KC_H:
		case OIS::KC_K:
		case OIS::KC_I:
		case OIS::KC_N:
		case OIS::KC_Y:
		case OIS::KC_B:
		case OIS::KC_T:
		case OIS::KC_G:
			mFocusObject.injectKeyDown(arg);
			break;
		case OIS::KC_J:
			{
				if(!mAnchors.empty()){
					if(mAnchors[mFocusAnchor].mInit) {
						bool fVisible = getVisible(mAnchors[mFocusAnchor].mEntityName);
						setMovableObject(mAnchors[mFocusAnchor].mEntityName ,!fVisible);
					}
				}
			}
			break;
		case OIS::KC_F:
			{
				if(!mAnchors.empty()){
					mFocusAnchor = (mFocusAnchor + 1) % mAnchors.size();
					if(mAnchors[mFocusAnchor].mInit) {
						bool fVisible = getVisible(mAnchors[mFocusAnchor].mEntityName);
						setMovableObject(mAnchors[mFocusAnchor].mEntityName ,fVisible);
					}
				}
			}
			break;

		case OIS::KC_X:
			{
				if(!mAnchors.empty()){
					mFocusAnchor = (mFocusAnchor + 1) % mAnchors.size();
					if(mAnchors[mFocusAnchor].mInit) {
						if(!mAnchors[mFocusAnchor].mAlignWithCamera) {
							updateAnchorToCameraOffset();
							mAnchors[mFocusAnchor].mAlignWithCamera  = true;
						} else {
							mAnchors[mFocusAnchor].mAlignWithCamera = false;
						}
					}
				}
			}
			break;

		case OIS::KC_V:
			{
				if(mOverlay && !mEvalCopy) {
					bool fVisible = mOverlay->isVisible();
					if(fVisible)
						mOverlay->hide();
					else
						mOverlay->show();
				}
			}
			break;

		case OIS::KC_0:
			setCameraPosForStream(0);
			break;
		case OIS::KC_9:
			setCameraPosForStream(9);
			break;
		case OIS::KC_1:
		case OIS::KC_2:
		case OIS::KC_3:
		case OIS::KC_4:
		case OIS::KC_5:
		case OIS::KC_6:
		case OIS::KC_7:
		case OIS::KC_8:
			{
				int nStrm = arg.key - OIS::KC_1 + 1;
				if(nStrm <= mStreams.size()){
					setCameraPosForStream(nStrm);
				}
			}
			break;

		case OIS::KC_Q:
			if(mShiftKeyPressed) {
				setDefaultCameraPosForStream(mFocusStream);
			} else {
				saveCameraPosForStream(mFocusStream);
			}
			break;

		case OIS::KC_L:
			if(mShiftKeyPressed) {
				int nOption = mLayout->getLayoutOption();
				nOption++;
				mLayout->setLayoutOption(nOption);
			} else if(mAltKeyPressed && mCustomCode == CUSTOM_TEAM_ZOOM){
				saveStreamLayout();
			} else {
				int nOption = mLayout->getThemeOption();
				nOption++;
				mLayout->setThemeOption(nOption);

			}
			break;

		case OIS::KC_P:
			TogleStreamPlayState();
			break;

		case OIS::KC_O:
			RestartStreamPlay();
			break;

		case OIS::KC_LSHIFT:
			mShiftKeyPressed = true;
			break;
		case OIS::KC_LMENU:
			mAltKeyPressed = true;
			break;

			
		case OIS::KC_W:
			mfAligningVideoUp = true;
			break;
		case OIS::KC_S:
			mfAligningVideoDn = true;
			break;
		case OIS::KC_D:
			mfAligningVideoRight = true;
			break;
		case OIS::KC_A:
			mfAligningVideoLeft = true;
			break;

		case OIS::KC_F1:
		case OIS::KC_F2:
		case OIS::KC_F3:
		case OIS::KC_F4:
		case OIS::KC_F5:
		case OIS::KC_F6:
		case OIS::KC_F7:
		case OIS::KC_F8:
		case OIS::KC_F9:
			mStitchVertex = arg.key - OIS::KC_F1;
			break;
	}
	return BaseApplication::keyPressed(arg);
}

bool OnyxVirtualStudio::keyReleased( const OIS::KeyEvent &arg )
{
	switch(arg.key) {
		case OIS::KC_U:
		case OIS::KC_M:
		case OIS::KC_H:
		case OIS::KC_K:
		case OIS::KC_I:
		case OIS::KC_N:
		case OIS::KC_Y:
		case OIS::KC_B:
		case OIS::KC_T:
		case OIS::KC_G:

			mFocusObject.injectKeyUp(arg);
			break;

		case OIS::KC_LSHIFT:
			mShiftKeyPressed = false;
			break;
		case OIS::KC_LMENU:
			mAltKeyPressed = false;
			break;
		
		case OIS::KC_W:
			mfAligningVideoUp = false;
			break;
		case OIS::KC_S:
			mfAligningVideoDn = false;
			break;
		case OIS::KC_D:
			mfAligningVideoRight = false;
			break;
		case OIS::KC_A:
			mfAligningVideoLeft = false;
			break;

	}
	return BaseApplication::keyReleased(arg);
}

bool OnyxVirtualStudio::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
    if(mWindow->isClosed())
        return false;

    if(mShutDown)
        return false;

	/* Process position or scaling commands for focus object */
	mFocusObject.frameRenderingQueued(evt);
	
	/* Process, if any exteranl commands */
	ExecExternalCmd();
	AlignAnchorWithCamera();

	UpdateStreamStatus();
	if(mfAligningVideoUp){
		moveVideoUp();
	} else if(mfAligningVideoDn){
		moveVideoDn();
	} else if(mfAligningVideoRight){
		moveVideoRight();
	} else if(mfAligningVideoLeft){
		moveVideoLeft();
	}
	if(mfStatusUpdate) {
		UpdateOnyxStatus();
	}
	return BaseApplication::frameRenderingQueued(evt);
}

void OnyxVirtualStudio::UpdateOnyxStatus()
{
	ONYX_STATUS_T OnyxStatus;
	LOCATION_T *pAnchor = &OnyxStatus.v.crntview.Anchor;
	LOCATION_T *pCamera = &OnyxStatus.v.crntview.Camera;
	Ogre::Vector3 camPos =  mCamera->getPosition();
	Ogre::Quaternion camOrient =  mCamera->getOrientation();

	OnyxStatus.v.crntview.lLayout = mLayout->mCrntLayoutOption;
	OnyxStatus.v.crntview.lWallpaper = mLayout->mCrntOption;
	pCamera->lPosX = mCamBounds.OnyxToUi(CNodeBounds::PROP_POS_X, camPos.x);
	pCamera->lPosY = mCamBounds.OnyxToUi(CNodeBounds::PROP_POS_Y, camPos.y);
	pCamera->lPosZ = mCamBounds.OnyxToUi(CNodeBounds::PROP_POS_Z, camPos.z);
	pCamera->lPitch = mCamBounds.OnyxToUi(CNodeBounds::PROP_PITCH, camOrient.getPitch().valueRadians());
	pCamera->lRoll = mCamBounds.OnyxToUi(CNodeBounds::PROP_ROLL, camOrient.getRoll().valueRadians());
	pCamera->lYaw = mCamBounds.OnyxToUi(CNodeBounds::PROP_YAW, camOrient.getYaw().valueRadians());

	CNodeBounds *pAnchorBounds = &mAnchorBounds[0];
	Ogre::SceneNode* nodeAnchor = mFocusObject.getTarget();
	if(nodeAnchor) {
		Ogre::Vector3 posAnchor =  nodeAnchor->getPosition();
		Ogre::Quaternion orientAnchor =  nodeAnchor->getOrientation();
		Ogre::Vector3 scale = nodeAnchor->getScale();
		pAnchor->lPosX = pAnchorBounds->OnyxToUi(CNodeBounds::PROP_POS_X, posAnchor.x);
		pAnchor->lPosY = pAnchorBounds->OnyxToUi(CNodeBounds::PROP_POS_Y, posAnchor.y);
		pAnchor->lPosZ = pAnchorBounds->OnyxToUi(CNodeBounds::PROP_POS_Z, posAnchor.z);
		pAnchor->lPitch = pAnchorBounds->OnyxToUi(CNodeBounds::PROP_PITCH, orientAnchor.getPitch().valueRadians());
		pAnchor->lRoll = pAnchorBounds->OnyxToUi(CNodeBounds::PROP_ROLL, orientAnchor.getRoll().valueRadians());
		pAnchor->lYaw = pAnchorBounds->OnyxToUi(CNodeBounds::PROP_YAW, orientAnchor.getYaw().valueRadians());
		pAnchor->lScale = scale.x * pAnchorBounds->mConvScale;
	} else {
		pAnchor->lPosX = 0;
		pAnchor->lPosY = 0;
		pAnchor->lPosZ = 0;
		pAnchor->lPitch = 0;
		pAnchor->lRoll = 0;
		pAnchor->lYaw = 0;
		pAnchor->lScale = 0;
	}
	ocntrlPostStatus(&OnyxStatus);
}

int nextPow2(int x)
{
	int y;
	for (y=1;y<x;y*=2);
	return y;
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
		HANDLE hSingleInstanceMutex = CreateMutex(NULL, TRUE, "OnyxRenderInstance");
		DWORD dwError = GetLastError();
		if (dwError == ERROR_ALREADY_EXISTS){
			return FALSE;
		}

        // Create application object
        OnyxVirtualStudio app;

        try {
			std::string strConfigPath;
			GetConfigFoderPath(strConfigPath);

			app.mLogCfg = strConfigPath + "/" + "Ogre.log";
			app.mOgreCfg = strConfigPath + "/" + "ogre.cfg";

            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
