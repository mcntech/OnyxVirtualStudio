/*
-----------------------------------------------------------------------------
Filename:    OnyxVirtualStudio.h
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC9 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#ifndef __OnyxVirtualStudio_h_
#define __OnyxVirtualStudio_h_

#include "BaseApplication.h"
#include "ObjectMotion.h"

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#include "../res/resource.h"
#endif

#define PLANE_MESH_XY "PlaneMeshXY"
#define PLANE_MESH_YZ "PlaneMeshYZ"
#define PLANE_MESH_ZX "PlaneMeshZX"

#define BACK_PLANE_MESH_XY "BackPlaneMeshXY"

#define MAX_ANCHORS          1
#define MAX_OUTPUTS          4
#define MAX_STREAMS	         6
#define MAX_ADVTS            1

#define ANCHOR_NAME_PREFIX   "Anchor"
#define STREAM_NAME_PREFIX   "Stream"
#define OUTPUT_NAME_PREFIX   "Output"
#define KEY_NAME_ALIAS       "Alias"

#define KEY_NAME_CAPTURE_DESTINAION   "Destination"

#define COLOR_KEY_VALUE_DEF  33 //0x00405040
#define COLOR_KEY_THRESH_DEF 0x00003000

class OnyxVirtualStudio;

typedef enum _STRM_TYPE_T
{
	STRM_TYPE_UNKNOWN,
	STRM_TYPE_DS_PLAY,
	STRM_TYPE_SKYPE_IN,
	STRM_TYPE_EXT_VIDIN,
	STRM_TYPE_VCAM_OUT,
} STRM_TYPE_T;

typedef enum _PLAY_STATUS_T
{
	STATUS_UNINIT,
	STATUS_STOP,
	STATUS_PUASE,
	STATUS_RUN
} PLAY_STATUS_T;


typedef enum _STREAM_TYPE_T
{
	STREAM_TYPE_ANCHOR,
	STREAM_TYPE_OVERLAY,
	STREAM_TYPE_DISPLAY
} STREAM_TYPE_T;

class CStream
{
public:
	CStream():mCameraPos(Ogre::Vector3::ZERO), mCameraDir(Ogre::Vector3::ZERO)
	{
		mColorKeyRatio = COLOR_KEY_VALUE_DEF;
		mColorKeyThresh = COLOR_KEY_THRESH_DEF;
		mEnableColorKey = 0;
		mAlias = false;
		mRoll = 0;
		mUpsideDown = false;
		mVertCropPercent = 0;
		mHorzCropPercent = 0;
		mCapWidth = 640;
		mCapHeight = 480;
		mIsPlaying = true; // Initial state
		mInit = false;
		mAlignWithCamera = false;
		mPlayStatus = STATUS_UNINIT;
	}
	~CStream(){};
	int streamType();

	std::string       mVideoStream;
	std::string       mAudioStream;
	std::string       mCallerId;			// Specific to Skype or SIP
	std::string       mEntityName;			// 3D Mesh Name
	std::string       mMaterial;
	bool              mIsPlaying;
	bool              mAlias;				// Material is from another stream
	unsigned long     mEnableColorKey;
	unsigned long     mColorKeyRatio;
	unsigned long     mColorKeyThresh;
	long              mRoll;
	unsigned long     mUpsideDown;
	int               mVertCropPercent;
	int               mHorzCropPercent;
	int               mCapWidth; 
	int               mCapHeight;

	bool              mInit;
	Ogre::Vector3     mCameraPos;			// Position of the camera when this stream got focus
	Ogre::Vector3     mCameraDir;			// Direction of the camera when this stream got focus

	// Anchor Specific
	Ogre::Vector3     mOffsetFromCamera;	// ofsset with respect to camera orientaion
											// when locked to camera. used for anchor
	bool              mAlignWithCamera;
	int               mPlayStatus;
};

class COutStream
{
public:
	COutStream()
	{
		mRoll = 0;
		mUpsideDown = false;
		mVertCropPercent = 0;
		mHorzCropPercent = 0;
		mWidth = 640;
		mHeight = 480;

		mIsPlaying = true; // Initial state
		mInit = false;
		mPlayStatus = STATUS_UNINIT;
	}
	~COutStream(){};
	int streamType();

	std::string       mVideoStream;
	std::string       mEntityName;			// 3D Mesh Name
	std::string       mMaterial;

	bool              mIsPlaying;
	long              mRoll;
	unsigned long     mUpsideDown;
	unsigned long     mWidth;
	unsigned long     mHeight;
	int               mVertCropPercent;
	int               mHorzCropPercent;
	bool              mInit;
	int               mPlayStatus;
};

class CLayout
{
public:
	CLayout()
	{
		mCrntOption = 0;
		mMaxOptions = 3;
		mMaxLayoutOptions = 1;
		mCrntLayoutOption = 0;
		mfBoarder = 1;
	}
	virtual ~CLayout(){}

	virtual int InitLayout(Ogre::SceneManager* mSceneMgr, int nSegments, Ogre::Real  AspectRatio, bool fEnable3dSticth) = 0;

	virtual void getAdvPanelPos(
		int              nAdvId,
		Ogre::Real    &Left, 
		Ogre::Real    &Top, 
		Ogre::Real     &Width, 
		Ogre::Real     &Height 
		) = 0;

	virtual void UpdateOption(){};
	virtual void UpdateLayoutOption(){};
	virtual void CropCorner(std::string entName, int nVertNum,  float du, float dv)
	{
	}
	virtual  void SetCrop(std::string entName, float left, float top, float right, float bottom) = 0;

	virtual void UpdatePlaneSize(
		std::string entName,
		Ogre::Real w, Ogre::Real h, 
		Ogre::Real vidLeft, Ogre::Real vidTop, Ogre::Real vidRight,  Ogre::Real vidBottom)= 0;

	virtual void SetRotation(std::string entName, int nRot)=0;
	int getThemeOption()
	{
		return mCrntOption;
	}
	void setThemeOption(int nOption)
	{
		if(nOption >= mMaxOptions || nOption < 0){
			nOption = 0;
		}
		if(mCrntOption != nOption){
			mCrntOption = nOption;
			UpdateOption();
		}
	}
	int getLayoutOption()
	{
		return mCrntLayoutOption;
	}

	void setLayoutOption(int nOption)
	{
		if(nOption >= mMaxLayoutOptions || nOption < 0){
			nOption = 0;
		}
		if(mCrntLayoutOption != nOption){
			mCrntLayoutOption = nOption;
			UpdateLayoutOption();
		}
	}

	int getMaxOptions()
	{
		return mMaxOptions;
	}
	virtual bool Is2DLayout() = 0;
	virtual void EnableStream(std::string &entity, bool fEnable) = 0;
	virtual void setMeshRotation(Ogre::String    &entName, Ogre::Real angle) = 0;
	virtual void setPitch(Ogre::String    &entName, Ogre::Real angle) = 0;
	int     mCrntOption;
	int     mMaxOptions;
	int     mCrntLayoutOption;
	int     mMaxLayoutOptions;
	bool    mfBoarder;

	Ogre::Sphere  mProjectionSphere;
};


class CMcnVCamIf : public Ogre::RenderTargetListener
{
public:
	CMcnVCamIf()
	{
		mRenderTexture = NULL;
		mMapFile = NULL;
		mSharedBuf = NULL;
	}
	~CMcnVCamIf();
	void CMcnVCamIf::Init(
				OnyxVirtualStudio *pParent, 
				Ogre::Camera *pCamera,
				const char   *vcamName,
				int          nWidth,
				int          nHeight);

	Ogre::RenderTexture *mRenderTexture;

    virtual void preRenderTargetUpdate(const Ogre::RenderTargetEvent& evt);
    virtual void postRenderTargetUpdate(const Ogre::RenderTargetEvent& evt);
	OnyxVirtualStudio *mParent;
	Ogre::PixelBox    *mPixelBox;
	std::string        mDestination;
	HANDLE            mMapFile;
	char              *mSharedBuf;

};

class CNodeBounds
{
public:
	enum {
		PROP_POS_X, PROP_POS_Y, PROP_POS_Z,
		PROP_PITCH, PROP_YAW, PROP_ROLL
	};
	
	CNodeBounds(){}
	void SetBounds(
		float fMinX, 
		float fMaxX,
		float fMinY, 
		float fMaxY,
		float fMinZ, 
		float fMaxZ,

		float fMinPitch, 
		float fMaxPitch,
		float fMinYaw, 
		float fMaxYaw,
		float fMinRoll,
		float fMaxRoll,
		float fConvScale 
		) 
	{
		mMaxX = fMaxX;
		mMinX = fMinX;
		mMaxY = fMaxY;
		mMinY = fMinY; 
		mMaxZ = fMaxZ;
		mMinZ = fMinZ;
		mMaxPitch = fMaxPitch;
		mMinPitch = fMinPitch; 
		mMaxYaw = fMaxYaw;
		mMinYaw = fMinYaw;	
		mMaxRoll = fMaxRoll;
		mMinRoll = fMinRoll;
		mConvScale = fConvScale;
	}

	float mMaxX;
	float mMinX; 
	float mMaxY;
	float mMinY; 
	float mMaxZ;
	float mMinZ; 

	float mMaxPitch;
	float mMinPitch; 
	float mMaxYaw;
	float mMinYaw; 
	float mMaxRoll;
	float mMinRoll; 

	float mConvScale;
	float UiToOnyx(int nProp, long lVal);
	long OnyxToUi(int nProp, float fVal);
};

class CEvalLogo
{
public:
	CEvalLogo()
	{
		mW= 640;
		mH= 50;
	}
	void createTexture(const Ogre::String& material_name);
	void destroyTexture();

	int mW;
	int mH;
	Ogre::TexturePtr	mTextPtr;
	Ogre::String  mTexturename;
};

class OnyxVirtualStudio : public BaseApplication, public Ogre::RenderTargetListener
{
public:
    OnyxVirtualStudio(void);
    virtual ~OnyxVirtualStudio(void);
	
	void OnyxVirtualStudio::createPlaneMeshXY(const char *szMeshName, Ogre::Real w, Ogre::Real h);
	void getGraphicsConfig(Ogre::ConfigFile      &cfg);

	void TogleStreamPlayState();
	void RestartStreamPlay();
	void UpdateStreamParam(CStream &Stream, const char *szParam);
	void createMovieSphere(
		Ogre::String name, 
		Ogre::String material_name,
		float left,float top,float right,float bottom);
	
	void moveVideoUp();
	void moveVideoDn();
	void moveVideoRight();
	void moveVideoLeft();
	void setVideoVerticalCrop();

	void setScale(
		Ogre::String     entName, 
		Ogre::Vector3    scale);

	void setMovableObject(
		Ogre::String     entName, 
		bool             fVisible);

	bool getVisible(
		Ogre::String     entName);

	bool OnyxVirtualStudio::getPosition(
		Ogre::String     entName,
		Ogre::Vector3    &pos);

	bool setPosition(
		Ogre::String     entName,
		Ogre::Vector3    &pos);


	void createOverlay(
			Ogre::String name, 
			Ogre::String material_name,
			float left,
			float top,
			float width,
			float height);

	void EnableOverlay(
			Ogre::String name,
			int fEnable);

	void createEvalLogo();
	void deleteEvalLogo();

	void setCameraPosForStream(int nStream);
	void saveCameraPosForStream(int nStream);
	void setDefaultCameraPosForStream(int nStream);
	void restoreCameraTarget(int nStream);
	void AlignAnchorWithCamera();
	void updateAnchorToCameraOffset();

    bool frameRenderingQueued(const Ogre::FrameEvent& evt);

	bool keyPressed( const OIS::KeyEvent &arg );
    virtual bool keyReleased( const OIS::KeyEvent &arg );
	void ExecExternalCmd();
	void UpdateStreamStatus();
	void UpdateDsVideo(CStream &oldStream, CStream &newStream, STREAM_TYPE_T   nStreamType);
	int InitDsVideo(CStream &Stream);
	void DeinitDsVideo(CStream &Stream);
	void saveStreamLayout();
	void restoreStreamLayout();

	void UpdateOnyxStatus();

protected:
    virtual void createScene(void);
    virtual void destroyScene(void);

	CStream *GetStream(const char *planeName, STREAM_TYPE_T &nStreamType);

	Ogre::Overlay *mOverlay;
	CLayout       *mLayout;
	CMcnVCamIf    *mVcamIf;

	int           mFocusAnchor;
	int           mFocusStream;
	int           mStitchVertex;
	float         mStichMoveIncrSmall;
	float         mStichMoveIncrBig;

	Ogre::String          mOVSConfigFileName;
	CObjectMotion         mFocusObject;
	std::vector<CStream>  mStreams;
	std::vector<CStream>  mAdvertisements;
	std::vector<CStream>  mAnchors;
	std::vector<COutStream>  mOutputs;
	bool                  mShiftKeyPressed;
	bool                  mAltKeyPressed;
	bool                  mEvalCopy;
	int                   mCustomCode;
	bool                  mfAligningVideoUp;
	bool                  mfAligningVideoDn;
	bool                  mfAligningVideoRight;
	bool                  mfAligningVideoLeft;
	int                   mLayoutId;
	std::string           mEvalLogo;
	bool                  mfStatusUpdate;
	CNodeBounds           mCamBounds;
	CNodeBounds           mAnchorBounds[MAX_ANCHORS];
	Ogre::Real            mAspectRatio;
};

#endif // #ifndef __OnyxVirtualStudio_h_
